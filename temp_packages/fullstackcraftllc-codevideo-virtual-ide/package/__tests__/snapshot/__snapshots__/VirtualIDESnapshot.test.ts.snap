// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`VirtualIDE Snapshot Test Rig should capture snapshots after every action: Snapshot after action 0 (file-explorer-create-folder) 1`] = `
"<div class="ide-snapshot"><div class="file-explorer"><h2>File Explorer</h2><pre>{
  "fileStructure": {
    "src": {
      "type": "directory",
      "content": "",
      "collapsed": false,
      "children": {}
    }
  }
}</pre></div><div class="editors"><h2>Editors</h2></div><div class="terminals"><h2>Terminals</h2><div class="terminal-instance"><pre></pre></div></div><div class="authors"><h2>Authors</h2><div class="author-instance"><p></p></div></div><div class="mouse"><h2>Mouse</h2><pre>{
  "x": 0,
  "y": 0,
  "timestamp": 0,
  "type": "move",
  "buttonStates": {
    "left": false,
    "right": false,
    "middle": false
  },
  "scrollPosition": {
    "x": 0,
    "y": 0
  }
}</pre></div></div>"
`;

exports[`VirtualIDE Snapshot Test Rig should capture snapshots after every action: Snapshot after action 1 (file-explorer-create-file) 1`] = `
"<div class="ide-snapshot"><div class="file-explorer"><h2>File Explorer</h2><pre>{
  "fileStructure": {
    "src": {
      "type": "directory",
      "content": "",
      "collapsed": false,
      "children": {
        "hello-world.js": {
          "type": "file",
          "content": "",
          "language": "js",
          "caretPosition": {
            "row": 0,
            "col": 0
          },
          "cursorPosition": {
            "x": 0,
            "y": 0
          }
        }
      }
    }
  }
}</pre></div><div class="editors"><h2>Editors</h2></div><div class="terminals"><h2>Terminals</h2><div class="terminal-instance"><pre></pre></div></div><div class="authors"><h2>Authors</h2><div class="author-instance"><p></p></div></div><div class="mouse"><h2>Mouse</h2><pre>{
  "x": 0,
  "y": 0,
  "timestamp": 0,
  "type": "move",
  "buttonStates": {
    "left": false,
    "right": false,
    "middle": false
  },
  "scrollPosition": {
    "x": 0,
    "y": 0
  }
}</pre></div></div>"
`;

exports[`VirtualIDE Snapshot Test Rig should capture snapshots after every action: Snapshot after action 2 (file-explorer-open-file) 1`] = `
"<div class="ide-snapshot"><div class="file-explorer"><h2>File Explorer</h2><pre>{
  "fileStructure": {
    "src": {
      "type": "directory",
      "content": "",
      "collapsed": false,
      "children": {
        "hello-world.js": {
          "type": "file",
          "content": "",
          "language": "js",
          "caretPosition": {
            "row": 0,
            "col": 0
          },
          "cursorPosition": {
            "x": 0,
            "y": 0
          }
        }
      }
    }
  }
}</pre></div><div class="editors"><h2>Editors</h2><div class="editor-instance"><h3>src/hello-world.js</h3><pre></pre><p>Saved: false</p></div></div><div class="terminals"><h2>Terminals</h2><div class="terminal-instance"><pre></pre></div></div><div class="authors"><h2>Authors</h2><div class="author-instance"><p></p></div></div><div class="mouse"><h2>Mouse</h2><pre>{
  "x": 0,
  "y": 0,
  "timestamp": 0,
  "type": "move",
  "buttonStates": {
    "left": false,
    "right": false,
    "middle": false
  },
  "scrollPosition": {
    "x": 0,
    "y": 0
  }
}</pre></div></div>"
`;

exports[`VirtualIDE Snapshot Test Rig should capture snapshots after every action: Snapshot after action 3 (mouse-click-editor) 1`] = `
"<div class="ide-snapshot"><div class="file-explorer"><h2>File Explorer</h2><pre>{
  "fileStructure": {
    "src": {
      "type": "directory",
      "content": "",
      "collapsed": false,
      "children": {
        "hello-world.js": {
          "type": "file",
          "content": "",
          "language": "js",
          "caretPosition": {
            "row": 0,
            "col": 0
          },
          "cursorPosition": {
            "x": 0,
            "y": 0
          }
        }
      }
    }
  }
}</pre></div><div class="editors"><h2>Editors</h2><div class="editor-instance"><h3>src/hello-world.js</h3><pre></pre><p>Saved: false</p></div></div><div class="terminals"><h2>Terminals</h2><div class="terminal-instance"><pre></pre></div></div><div class="authors"><h2>Authors</h2><div class="author-instance"><p></p></div></div><div class="mouse"><h2>Mouse</h2><pre>{
  "x": 0,
  "y": 0,
  "timestamp": 0,
  "type": "move",
  "buttonStates": {
    "left": false,
    "right": false,
    "middle": false
  },
  "scrollPosition": {
    "x": 0,
    "y": 0
  }
}</pre></div></div>"
`;

exports[`VirtualIDE Snapshot Test Rig should capture snapshots after every action: Snapshot after action 4 (editor-type) 1`] = `
"<div class="ide-snapshot"><div class="file-explorer"><h2>File Explorer</h2><pre>{
  "fileStructure": {
    "src": {
      "type": "directory",
      "content": "",
      "collapsed": false,
      "children": {
        "hello-world.js": {
          "type": "file",
          "content": "",
          "language": "js",
          "caretPosition": {
            "row": 0,
            "col": 0
          },
          "cursorPosition": {
            "x": 0,
            "y": 0
          }
        }
      }
    }
  }
}</pre></div><div class="editors"><h2>Editors</h2><div class="editor-instance"><h3>src/hello-world.js</h3><pre>console.log('Hello, world!');</pre><p>Saved: false</p></div></div><div class="terminals"><h2>Terminals</h2><div class="terminal-instance"><pre></pre></div></div><div class="authors"><h2>Authors</h2><div class="author-instance"><p></p></div></div><div class="mouse"><h2>Mouse</h2><pre>{
  "x": 0,
  "y": 0,
  "timestamp": 0,
  "type": "move",
  "buttonStates": {
    "left": false,
    "right": false,
    "middle": false
  },
  "scrollPosition": {
    "x": 0,
    "y": 0
  }
}</pre></div></div>"
`;

exports[`VirtualIDE Snapshot Test Rig should capture snapshots after every action: Snapshot after action 5 (editor-save) 1`] = `
"<div class="ide-snapshot"><div class="file-explorer"><h2>File Explorer</h2><pre>{
  "fileStructure": {
    "src": {
      "type": "directory",
      "content": "",
      "collapsed": false,
      "children": {
        "hello-world.js": {
          "type": "file",
          "content": "",
          "language": "js",
          "caretPosition": {
            "row": 0,
            "col": 0
          },
          "cursorPosition": {
            "x": 0,
            "y": 0
          }
        }
      }
    }
  }
}</pre></div><div class="editors"><h2>Editors</h2><div class="editor-instance"><h3>src/hello-world.js</h3><pre>console.log('Hello, world!');</pre><p>Saved: true</p></div></div><div class="terminals"><h2>Terminals</h2><div class="terminal-instance"><pre></pre></div></div><div class="authors"><h2>Authors</h2><div class="author-instance"><p></p></div></div><div class="mouse"><h2>Mouse</h2><pre>{
  "x": 0,
  "y": 0,
  "timestamp": 0,
  "type": "move",
  "buttonStates": {
    "left": false,
    "right": false,
    "middle": false
  },
  "scrollPosition": {
    "x": 0,
    "y": 0
  }
}</pre></div></div>"
`;

exports[`VirtualIDE Snapshot Test Rig should capture snapshots after every action: Snapshot after action 6 (terminal-open) 1`] = `
"<div class="ide-snapshot"><div class="file-explorer"><h2>File Explorer</h2><pre>{
  "fileStructure": {
    "src": {
      "type": "directory",
      "content": "",
      "collapsed": false,
      "children": {
        "hello-world.js": {
          "type": "file",
          "content": "",
          "language": "js",
          "caretPosition": {
            "row": 0,
            "col": 0
          },
          "cursorPosition": {
            "x": 0,
            "y": 0
          }
        }
      }
    }
  }
}</pre></div><div class="editors"><h2>Editors</h2><div class="editor-instance"><h3>src/hello-world.js</h3><pre>console.log('Hello, world!');</pre><p>Saved: true</p></div></div><div class="terminals"><h2>Terminals</h2><div class="terminal-instance"><pre></pre></div></div><div class="authors"><h2>Authors</h2><div class="author-instance"><p></p></div></div><div class="mouse"><h2>Mouse</h2><pre>{
  "x": 0,
  "y": 0,
  "timestamp": 0,
  "type": "move",
  "buttonStates": {
    "left": false,
    "right": false,
    "middle": false
  },
  "scrollPosition": {
    "x": 0,
    "y": 0
  }
}</pre></div></div>"
`;

exports[`VirtualIDE Snapshot Test Rig should capture snapshots after every action: Snapshot after action 7 (mouse-click-terminal) 1`] = `
"<div class="ide-snapshot"><div class="file-explorer"><h2>File Explorer</h2><pre>{
  "fileStructure": {
    "src": {
      "type": "directory",
      "content": "",
      "collapsed": false,
      "children": {
        "hello-world.js": {
          "type": "file",
          "content": "",
          "language": "js",
          "caretPosition": {
            "row": 0,
            "col": 0
          },
          "cursorPosition": {
            "x": 0,
            "y": 0
          }
        }
      }
    }
  }
}</pre></div><div class="editors"><h2>Editors</h2><div class="editor-instance"><h3>src/hello-world.js</h3><pre>console.log('Hello, world!');</pre><p>Saved: true</p></div></div><div class="terminals"><h2>Terminals</h2><div class="terminal-instance"><pre></pre></div></div><div class="authors"><h2>Authors</h2><div class="author-instance"><p></p></div></div><div class="mouse"><h2>Mouse</h2><pre>{
  "x": 0,
  "y": 0,
  "timestamp": 0,
  "type": "move",
  "buttonStates": {
    "left": false,
    "right": false,
    "middle": false
  },
  "scrollPosition": {
    "x": 0,
    "y": 0
  }
}</pre></div></div>"
`;

exports[`VirtualIDE Snapshot Test Rig should capture snapshots after every action: Snapshot after action 8 (terminal-type) 1`] = `
"<div class="ide-snapshot"><div class="file-explorer"><h2>File Explorer</h2><pre>{
  "fileStructure": {
    "src": {
      "type": "directory",
      "content": "",
      "collapsed": false,
      "children": {
        "hello-world.js": {
          "type": "file",
          "content": "",
          "language": "js",
          "caretPosition": {
            "row": 0,
            "col": 0
          },
          "cursorPosition": {
            "x": 0,
            "y": 0
          }
        }
      }
    }
  }
}</pre></div><div class="editors"><h2>Editors</h2><div class="editor-instance"><h3>src/hello-world.js</h3><pre>console.log('Hello, world!');</pre><p>Saved: true</p></div></div><div class="terminals"><h2>Terminals</h2><div class="terminal-instance"><pre>node src/hello-world.js</pre></div></div><div class="authors"><h2>Authors</h2><div class="author-instance"><p></p></div></div><div class="mouse"><h2>Mouse</h2><pre>{
  "x": 0,
  "y": 0,
  "timestamp": 0,
  "type": "move",
  "buttonStates": {
    "left": false,
    "right": false,
    "middle": false
  },
  "scrollPosition": {
    "x": 0,
    "y": 0
  }
}</pre></div></div>"
`;

exports[`VirtualIDE Snapshot Test Rig should capture snapshots after every action: Snapshot after action 9 (terminal-enter) 1`] = `
"<div class="ide-snapshot"><div class="file-explorer"><h2>File Explorer</h2><pre>{
  "fileStructure": {
    "src": {
      "type": "directory",
      "content": "",
      "collapsed": false,
      "children": {
        "hello-world.js": {
          "type": "file",
          "content": "",
          "language": "js",
          "caretPosition": {
            "row": 0,
            "col": 0
          },
          "cursorPosition": {
            "x": 0,
            "y": 0
          }
        }
      }
    }
  }
}</pre></div><div class="editors"><h2>Editors</h2><div class="editor-instance"><h3>src/hello-world.js</h3><pre>console.log('Hello, world!');</pre><p>Saved: true</p></div></div><div class="terminals"><h2>Terminals</h2><div class="terminal-instance"><pre></pre></div></div><div class="authors"><h2>Authors</h2><div class="author-instance"><p></p></div></div><div class="mouse"><h2>Mouse</h2><pre>{
  "x": 0,
  "y": 0,
  "timestamp": 0,
  "type": "move",
  "buttonStates": {
    "left": false,
    "right": false,
    "middle": false
  },
  "scrollPosition": {
    "x": 0,
    "y": 0
  }
}</pre></div></div>"
`;

exports[`VirtualIDE Snapshot Test Rig with HTML Files should capture snapshots after every action and write raw HTML files: Snapshot after action 0 (file-explorer-create-folder) 1`] = `
"<div class="ide-snapshot"><div class="file-explorer"><h2>File Explorer</h2><pre>{
  "fileStructure": {
    "src": {
      "type": "directory",
      "content": "",
      "collapsed": false,
      "children": {}
    }
  }
}</pre></div><div class="editors"><h2>Editors</h2></div><div class="terminals"><h2>Terminals</h2><div class="terminal-instance"><pre></pre></div></div><div class="authors"><h2>Authors</h2><div class="author-instance"><p></p></div></div><div class="mouse"><h2>Mouse</h2><pre>{
  "x": 0,
  "y": 0,
  "timestamp": 0,
  "type": "move",
  "buttonStates": {
    "left": false,
    "right": false,
    "middle": false
  },
  "scrollPosition": {
    "x": 0,
    "y": 0
  }
}</pre></div></div>"
`;

exports[`VirtualIDE Snapshot Test Rig with HTML Files should capture snapshots after every action and write raw HTML files: Snapshot after action 1 (file-explorer-create-file) 1`] = `
"<div class="ide-snapshot"><div class="file-explorer"><h2>File Explorer</h2><pre>{
  "fileStructure": {
    "src": {
      "type": "directory",
      "content": "",
      "collapsed": false,
      "children": {
        "hello-world.js": {
          "type": "file",
          "content": "",
          "language": "js",
          "caretPosition": {
            "row": 0,
            "col": 0
          },
          "cursorPosition": {
            "x": 0,
            "y": 0
          }
        }
      }
    }
  }
}</pre></div><div class="editors"><h2>Editors</h2></div><div class="terminals"><h2>Terminals</h2><div class="terminal-instance"><pre></pre></div></div><div class="authors"><h2>Authors</h2><div class="author-instance"><p></p></div></div><div class="mouse"><h2>Mouse</h2><pre>{
  "x": 0,
  "y": 0,
  "timestamp": 0,
  "type": "move",
  "buttonStates": {
    "left": false,
    "right": false,
    "middle": false
  },
  "scrollPosition": {
    "x": 0,
    "y": 0
  }
}</pre></div></div>"
`;

exports[`VirtualIDE Snapshot Test Rig with HTML Files should capture snapshots after every action and write raw HTML files: Snapshot after action 2 (file-explorer-open-file) 1`] = `
"<div class="ide-snapshot"><div class="file-explorer"><h2>File Explorer</h2><pre>{
  "fileStructure": {
    "src": {
      "type": "directory",
      "content": "",
      "collapsed": false,
      "children": {
        "hello-world.js": {
          "type": "file",
          "content": "",
          "language": "js",
          "caretPosition": {
            "row": 0,
            "col": 0
          },
          "cursorPosition": {
            "x": 0,
            "y": 0
          }
        }
      }
    }
  }
}</pre></div><div class="editors"><h2>Editors</h2><div class="editor-instance"><h3>src/hello-world.js</h3><pre></pre><p>Saved: false</p></div></div><div class="terminals"><h2>Terminals</h2><div class="terminal-instance"><pre></pre></div></div><div class="authors"><h2>Authors</h2><div class="author-instance"><p></p></div></div><div class="mouse"><h2>Mouse</h2><pre>{
  "x": 0,
  "y": 0,
  "timestamp": 0,
  "type": "move",
  "buttonStates": {
    "left": false,
    "right": false,
    "middle": false
  },
  "scrollPosition": {
    "x": 0,
    "y": 0
  }
}</pre></div></div>"
`;

exports[`VirtualIDE Snapshot Test Rig with HTML Files should capture snapshots after every action and write raw HTML files: Snapshot after action 3 (mouse-click-editor) 1`] = `
"<div class="ide-snapshot"><div class="file-explorer"><h2>File Explorer</h2><pre>{
  "fileStructure": {
    "src": {
      "type": "directory",
      "content": "",
      "collapsed": false,
      "children": {
        "hello-world.js": {
          "type": "file",
          "content": "",
          "language": "js",
          "caretPosition": {
            "row": 0,
            "col": 0
          },
          "cursorPosition": {
            "x": 0,
            "y": 0
          }
        }
      }
    }
  }
}</pre></div><div class="editors"><h2>Editors</h2><div class="editor-instance"><h3>src/hello-world.js</h3><pre></pre><p>Saved: false</p></div></div><div class="terminals"><h2>Terminals</h2><div class="terminal-instance"><pre></pre></div></div><div class="authors"><h2>Authors</h2><div class="author-instance"><p></p></div></div><div class="mouse"><h2>Mouse</h2><pre>{
  "x": 0,
  "y": 0,
  "timestamp": 0,
  "type": "move",
  "buttonStates": {
    "left": false,
    "right": false,
    "middle": false
  },
  "scrollPosition": {
    "x": 0,
    "y": 0
  }
}</pre></div></div>"
`;

exports[`VirtualIDE Snapshot Test Rig with HTML Files should capture snapshots after every action and write raw HTML files: Snapshot after action 4 (editor-type) 1`] = `
"<div class="ide-snapshot"><div class="file-explorer"><h2>File Explorer</h2><pre>{
  "fileStructure": {
    "src": {
      "type": "directory",
      "content": "",
      "collapsed": false,
      "children": {
        "hello-world.js": {
          "type": "file",
          "content": "",
          "language": "js",
          "caretPosition": {
            "row": 0,
            "col": 0
          },
          "cursorPosition": {
            "x": 0,
            "y": 0
          }
        }
      }
    }
  }
}</pre></div><div class="editors"><h2>Editors</h2><div class="editor-instance"><h3>src/hello-world.js</h3><pre>console.log('Hello, world!');</pre><p>Saved: false</p></div></div><div class="terminals"><h2>Terminals</h2><div class="terminal-instance"><pre></pre></div></div><div class="authors"><h2>Authors</h2><div class="author-instance"><p></p></div></div><div class="mouse"><h2>Mouse</h2><pre>{
  "x": 0,
  "y": 0,
  "timestamp": 0,
  "type": "move",
  "buttonStates": {
    "left": false,
    "right": false,
    "middle": false
  },
  "scrollPosition": {
    "x": 0,
    "y": 0
  }
}</pre></div></div>"
`;

exports[`VirtualIDE Snapshot Test Rig with HTML Files should capture snapshots after every action and write raw HTML files: Snapshot after action 5 (editor-save) 1`] = `
"<div class="ide-snapshot"><div class="file-explorer"><h2>File Explorer</h2><pre>{
  "fileStructure": {
    "src": {
      "type": "directory",
      "content": "",
      "collapsed": false,
      "children": {
        "hello-world.js": {
          "type": "file",
          "content": "",
          "language": "js",
          "caretPosition": {
            "row": 0,
            "col": 0
          },
          "cursorPosition": {
            "x": 0,
            "y": 0
          }
        }
      }
    }
  }
}</pre></div><div class="editors"><h2>Editors</h2><div class="editor-instance"><h3>src/hello-world.js</h3><pre>console.log('Hello, world!');</pre><p>Saved: true</p></div></div><div class="terminals"><h2>Terminals</h2><div class="terminal-instance"><pre></pre></div></div><div class="authors"><h2>Authors</h2><div class="author-instance"><p></p></div></div><div class="mouse"><h2>Mouse</h2><pre>{
  "x": 0,
  "y": 0,
  "timestamp": 0,
  "type": "move",
  "buttonStates": {
    "left": false,
    "right": false,
    "middle": false
  },
  "scrollPosition": {
    "x": 0,
    "y": 0
  }
}</pre></div></div>"
`;

exports[`VirtualIDE Snapshot Test Rig with HTML Files should capture snapshots after every action and write raw HTML files: Snapshot after action 6 (terminal-open) 1`] = `
"<div class="ide-snapshot"><div class="file-explorer"><h2>File Explorer</h2><pre>{
  "fileStructure": {
    "src": {
      "type": "directory",
      "content": "",
      "collapsed": false,
      "children": {
        "hello-world.js": {
          "type": "file",
          "content": "",
          "language": "js",
          "caretPosition": {
            "row": 0,
            "col": 0
          },
          "cursorPosition": {
            "x": 0,
            "y": 0
          }
        }
      }
    }
  }
}</pre></div><div class="editors"><h2>Editors</h2><div class="editor-instance"><h3>src/hello-world.js</h3><pre>console.log('Hello, world!');</pre><p>Saved: true</p></div></div><div class="terminals"><h2>Terminals</h2><div class="terminal-instance"><pre></pre></div></div><div class="authors"><h2>Authors</h2><div class="author-instance"><p></p></div></div><div class="mouse"><h2>Mouse</h2><pre>{
  "x": 0,
  "y": 0,
  "timestamp": 0,
  "type": "move",
  "buttonStates": {
    "left": false,
    "right": false,
    "middle": false
  },
  "scrollPosition": {
    "x": 0,
    "y": 0
  }
}</pre></div></div>"
`;

exports[`VirtualIDE Snapshot Test Rig with HTML Files should capture snapshots after every action and write raw HTML files: Snapshot after action 7 (mouse-click-terminal) 1`] = `
"<div class="ide-snapshot"><div class="file-explorer"><h2>File Explorer</h2><pre>{
  "fileStructure": {
    "src": {
      "type": "directory",
      "content": "",
      "collapsed": false,
      "children": {
        "hello-world.js": {
          "type": "file",
          "content": "",
          "language": "js",
          "caretPosition": {
            "row": 0,
            "col": 0
          },
          "cursorPosition": {
            "x": 0,
            "y": 0
          }
        }
      }
    }
  }
}</pre></div><div class="editors"><h2>Editors</h2><div class="editor-instance"><h3>src/hello-world.js</h3><pre>console.log('Hello, world!');</pre><p>Saved: true</p></div></div><div class="terminals"><h2>Terminals</h2><div class="terminal-instance"><pre></pre></div></div><div class="authors"><h2>Authors</h2><div class="author-instance"><p></p></div></div><div class="mouse"><h2>Mouse</h2><pre>{
  "x": 0,
  "y": 0,
  "timestamp": 0,
  "type": "move",
  "buttonStates": {
    "left": false,
    "right": false,
    "middle": false
  },
  "scrollPosition": {
    "x": 0,
    "y": 0
  }
}</pre></div></div>"
`;

exports[`VirtualIDE Snapshot Test Rig with HTML Files should capture snapshots after every action and write raw HTML files: Snapshot after action 8 (terminal-type) 1`] = `
"<div class="ide-snapshot"><div class="file-explorer"><h2>File Explorer</h2><pre>{
  "fileStructure": {
    "src": {
      "type": "directory",
      "content": "",
      "collapsed": false,
      "children": {
        "hello-world.js": {
          "type": "file",
          "content": "",
          "language": "js",
          "caretPosition": {
            "row": 0,
            "col": 0
          },
          "cursorPosition": {
            "x": 0,
            "y": 0
          }
        }
      }
    }
  }
}</pre></div><div class="editors"><h2>Editors</h2><div class="editor-instance"><h3>src/hello-world.js</h3><pre>console.log('Hello, world!');</pre><p>Saved: true</p></div></div><div class="terminals"><h2>Terminals</h2><div class="terminal-instance"><pre>node src/hello-world.js</pre></div></div><div class="authors"><h2>Authors</h2><div class="author-instance"><p></p></div></div><div class="mouse"><h2>Mouse</h2><pre>{
  "x": 0,
  "y": 0,
  "timestamp": 0,
  "type": "move",
  "buttonStates": {
    "left": false,
    "right": false,
    "middle": false
  },
  "scrollPosition": {
    "x": 0,
    "y": 0
  }
}</pre></div></div>"
`;

exports[`VirtualIDE Snapshot Test Rig with HTML Files should capture snapshots after every action and write raw HTML files: Snapshot after action 9 (terminal-enter) 1`] = `
"<div class="ide-snapshot"><div class="file-explorer"><h2>File Explorer</h2><pre>{
  "fileStructure": {
    "src": {
      "type": "directory",
      "content": "",
      "collapsed": false,
      "children": {
        "hello-world.js": {
          "type": "file",
          "content": "",
          "language": "js",
          "caretPosition": {
            "row": 0,
            "col": 0
          },
          "cursorPosition": {
            "x": 0,
            "y": 0
          }
        }
      }
    }
  }
}</pre></div><div class="editors"><h2>Editors</h2><div class="editor-instance"><h3>src/hello-world.js</h3><pre>console.log('Hello, world!');</pre><p>Saved: true</p></div></div><div class="terminals"><h2>Terminals</h2><div class="terminal-instance"><pre></pre></div></div><div class="authors"><h2>Authors</h2><div class="author-instance"><p></p></div></div><div class="mouse"><h2>Mouse</h2><pre>{
  "x": 0,
  "y": 0,
  "timestamp": 0,
  "type": "move",
  "buttonStates": {
    "left": false,
    "right": false,
    "middle": false
  },
  "scrollPosition": {
    "x": 0,
    "y": 0
  }
}</pre></div></div>"
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 0 (author-speak-before) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;"></pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Today, we're going to learn about how to use the console.log function in JavaScript.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 0 (file-explorer-create-file) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript"></code></pre>
          
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 0 (file-explorer-create-folder) 1`] = `
"
    <!DOCTYPE html>
    <html>
      <head>
        <meta charset="UTF-8">
        <title>VirtualIDE Snapshot</title>
      </head>
      <body style="margin:0; padding:0; font-family: monospace;">
        <div style="display: flex; flex-direction: column; height: 100vh;">
          <!-- Main IDE Area -->
          <div style="flex: 1; display: flex;">
            <!-- Left: File Explorer -->
            <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
              <h3 style="margin: 0 0 5px 0; border-bottom: 1px solid black;">File Explorer</h3>
              <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">
                     <strong>src</strong><ul style='list-style: none; padding-left: 10px; margin: 0;'></ul></li></ul>
            </div>
            <!-- Right: Editor -->
            <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column;">
              <!-- Editor Tabs -->
              <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
                
              </div>
              <!-- Editor Content -->
              <div style="flex: 1; padding: 5px; overflow: auto;">
                <pre style="margin:0;"></pre>
              </div>
            </div>
          </div>
          <!-- Bottom: Terminal -->
          <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
            <div style="font-weight: bold;">codevideo &gt; </div>
            <pre style="margin:0;"></pre>
          </div>
        </div>
      </body>
    </html>
    "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 1 (author-speak-before) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;"></pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Let's first create a src folder.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 1 (file-explorer-create-file) 1`] = `
"
    <!DOCTYPE html>
    <html>
      <head>
        <meta charset="UTF-8">
        <title>VirtualIDE Snapshot</title>
      </head>
      <body style="margin:0; padding:0; font-family: monospace;">
        <div style="display: flex; flex-direction: column; height: 100vh;">
          <!-- Main IDE Area -->
          <div style="flex: 1; display: flex;">
            <!-- Left: File Explorer -->
            <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
              <h3 style="margin: 0 0 5px 0; border-bottom: 1px solid black;">File Explorer</h3>
              <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">
                     <strong>src</strong><ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">hello-world.js</li></ul></li></ul>
            </div>
            <!-- Right: Editor -->
            <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column;">
              <!-- Editor Tabs -->
              <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
                
              </div>
              <!-- Editor Content -->
              <div style="flex: 1; padding: 5px; overflow: auto;">
                <pre style="margin:0;"></pre>
              </div>
            </div>
          </div>
          <!-- Bottom: Terminal -->
          <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
            <div style="font-weight: bold;">codevideo &gt; </div>
            <pre style="margin:0;"></pre>
          </div>
        </div>
      </body>
    </html>
    "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 1 (file-explorer-open-file) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript"></code></pre>
          
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 2 (author-speak-before) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;"></pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      This particular problem was from day 11 of this year's Advent of Code - the challenge that came out on December 11th.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 2 (file-explorer-create-folder) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;"><strong>src</strong><ul style='list-style: none; padding-left: 10px; margin: 0;'></ul></li></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;"></pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Let's first create a src folder.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 2 (file-explorer-open-file) 1`] = `
"
    <!DOCTYPE html>
    <html>
      <head>
        <meta charset="UTF-8">
        <title>VirtualIDE Snapshot</title>
      </head>
      <body style="margin:0; padding:0; font-family: monospace;">
        <div style="display: flex; flex-direction: column; height: 100vh;">
          <!-- Main IDE Area -->
          <div style="flex: 1; display: flex;">
            <!-- Left: File Explorer -->
            <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
              <h3 style="margin: 0 0 5px 0; border-bottom: 1px solid black;">File Explorer</h3>
              <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">
                     <strong>src</strong><ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">hello-world.js</li></ul></li></ul>
            </div>
            <!-- Right: Editor -->
            <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column;">
              <!-- Editor Tabs -->
              <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
                
        <div style="
            padding: 2px 5px;
            border: 1px solid black;
            margin-right: 5px;
            background: #ddd;
            display: inline-block;
            ">
          src/hello-world.js <span style="color: red;">x</span>
        </div>
              </div>
              <!-- Editor Content -->
              <div style="flex: 1; padding: 5px; overflow: auto;">
                <pre style="margin:0;"></pre>
              </div>
            </div>
          </div>
          <!-- Bottom: Terminal -->
          <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
            <div style="font-weight: bold;">codevideo &gt; </div>
            <pre style="margin:0;"></pre>
          </div>
        </div>
      </body>
    </html>
    "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 3 (author-speak-before) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;"><strong>src</strong><ul style='list-style: none; padding-left: 10px; margin: 0;'></ul></li></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;"></pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      and now let's create a hello-world.js file inside it.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 3 (mouse-click-editor) 1`] = `
"
    <!DOCTYPE html>
    <html>
      <head>
        <meta charset="UTF-8">
        <title>VirtualIDE Snapshot</title>
      </head>
      <body style="margin:0; padding:0; font-family: monospace;">
        <div style="display: flex; flex-direction: column; height: 100vh;">
          <!-- Main IDE Area -->
          <div style="flex: 1; display: flex;">
            <!-- Left: File Explorer -->
            <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
              <h3 style="margin: 0 0 5px 0; border-bottom: 1px solid black;">File Explorer</h3>
              <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">
                     <strong>src</strong><ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">hello-world.js</li></ul></li></ul>
            </div>
            <!-- Right: Editor -->
            <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column;">
              <!-- Editor Tabs -->
              <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
                
        <div style="
            padding: 2px 5px;
            border: 1px solid black;
            margin-right: 5px;
            background: #ddd;
            display: inline-block;
            ">
          src/hello-world.js <span style="color: red;">x</span>
        </div>
              </div>
              <!-- Editor Content -->
              <div style="flex: 1; padding: 5px; overflow: auto;">
                <pre style="margin:0;"></pre>
              </div>
            </div>
          </div>
          <!-- Bottom: Terminal -->
          <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
            <div style="font-weight: bold;">codevideo &gt; </div>
            <pre style="margin:0;"></pre>
          </div>
        </div>
      </body>
    </html>
    "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 4 (author-speak-before) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript"></code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      This particular problem was from day 11 of 2024's Advent of Code - the challenge that came out on December 11th, 2024.
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 4 (editor-type) 1`] = `
"
    <!DOCTYPE html>
    <html>
      <head>
        <meta charset="UTF-8">
        <title>VirtualIDE Snapshot</title>
      </head>
      <body style="margin:0; padding:0; font-family: monospace;">
        <div style="display: flex; flex-direction: column; height: 100vh;">
          <!-- Main IDE Area -->
          <div style="flex: 1; display: flex;">
            <!-- Left: File Explorer -->
            <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
              <h3 style="margin: 0 0 5px 0; border-bottom: 1px solid black;">File Explorer</h3>
              <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">
                     <strong>src</strong><ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">hello-world.js</li></ul></li></ul>
            </div>
            <!-- Right: Editor -->
            <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column;">
              <!-- Editor Tabs -->
              <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
                
        <div style="
            padding: 2px 5px;
            border: 1px solid black;
            margin-right: 5px;
            background: #ddd;
            display: inline-block;
            ">
          src/hello-world.js <span style="color: red;">x</span>
        </div>
              </div>
              <!-- Editor Content -->
              <div style="flex: 1; padding: 5px; overflow: auto;">
                <pre style="margin:0;">console.log('Hello, world!');</pre>
              </div>
            </div>
          </div>
          <!-- Bottom: Terminal -->
          <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
            <div style="font-weight: bold;">codevideo &gt; </div>
            <pre style="margin:0;"></pre>
          </div>
        </div>
      </body>
    </html>
    "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 4 (file-explorer-create-file) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;"><strong>src</strong><ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">hello-world.js</li></ul></li></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;"></pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      and now let's create a hello-world.js file inside it.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 5 (author-speak-before) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;"><strong>src</strong><ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">hello-world.js</li></ul></li></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;"></pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Let's open up hello-world.js now...
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 5 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">// First, let's implement a naive solution for Part 1
</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Let's start by looking at the problem. We need to simulate some strange stones that change every time we blink...
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 5 (editor-save) 1`] = `
"
    <!DOCTYPE html>
    <html>
      <head>
        <meta charset="UTF-8">
        <title>VirtualIDE Snapshot</title>
      </head>
      <body style="margin:0; padding:0; font-family: monospace;">
        <div style="display: flex; flex-direction: column; height: 100vh;">
          <!-- Main IDE Area -->
          <div style="flex: 1; display: flex;">
            <!-- Left: File Explorer -->
            <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
              <h3 style="margin: 0 0 5px 0; border-bottom: 1px solid black;">File Explorer</h3>
              <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">
                     <strong>src</strong><ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">hello-world.js</li></ul></li></ul>
            </div>
            <!-- Right: Editor -->
            <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column;">
              <!-- Editor Tabs -->
              <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
                
        <div style="
            padding: 2px 5px;
            border: 1px solid black;
            margin-right: 5px;
            background: #ddd;
            display: inline-block;
            ">
          src/hello-world.js <span style="color: green;">•</span>
        </div>
              </div>
              <!-- Editor Content -->
              <div style="flex: 1; padding: 5px; overflow: auto;">
                <pre style="margin:0;">console.log('Hello, world!');</pre>
              </div>
            </div>
          </div>
          <!-- Bottom: Terminal -->
          <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
            <div style="font-weight: bold;">codevideo &gt; </div>
            <pre style="margin:0;"></pre>
          </div>
        </div>
      </body>
    </html>
    "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 6 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Let's start by looking at the problem. We need to simulate some strange stones that change every time we blink...
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 6 (file-explorer-open-file) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;"><strong>src</strong><ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">hello-world.js</li></ul></li></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        src/hello-world.js <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;"></pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Let's open up hello-world.js now...
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 6 (terminal-open) 1`] = `
"
    <!DOCTYPE html>
    <html>
      <head>
        <meta charset="UTF-8">
        <title>VirtualIDE Snapshot</title>
      </head>
      <body style="margin:0; padding:0; font-family: monospace;">
        <div style="display: flex; flex-direction: column; height: 100vh;">
          <!-- Main IDE Area -->
          <div style="flex: 1; display: flex;">
            <!-- Left: File Explorer -->
            <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
              <h3 style="margin: 0 0 5px 0; border-bottom: 1px solid black;">File Explorer</h3>
              <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">
                     <strong>src</strong><ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">hello-world.js</li></ul></li></ul>
            </div>
            <!-- Right: Editor -->
            <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column;">
              <!-- Editor Tabs -->
              <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
                
        <div style="
            padding: 2px 5px;
            border: 1px solid black;
            margin-right: 5px;
            background: #ddd;
            display: inline-block;
            ">
          src/hello-world.js <span style="color: green;">•</span>
        </div>
              </div>
              <!-- Editor Content -->
              <div style="flex: 1; padding: 5px; overflow: auto;">
                <pre style="margin:0;">console.log('Hello, world!');</pre>
              </div>
            </div>
          </div>
          <!-- Bottom: Terminal -->
          <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
            <div style="font-weight: bold;">codevideo &gt; </div>
            <pre style="margin:0;"></pre>
          </div>
        </div>
      </body>
    </html>
    "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 7 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Let's start by looking at the problem. We need to simulate some strange stones that change every time we blink...
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 7 (mouse-click-editor) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;"><strong>src</strong><ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">hello-world.js</li></ul></li></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        src/hello-world.js <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;"></pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Let's open up hello-world.js now...
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 7 (mouse-click-terminal) 1`] = `
"
    <!DOCTYPE html>
    <html>
      <head>
        <meta charset="UTF-8">
        <title>VirtualIDE Snapshot</title>
      </head>
      <body style="margin:0; padding:0; font-family: monospace;">
        <div style="display: flex; flex-direction: column; height: 100vh;">
          <!-- Main IDE Area -->
          <div style="flex: 1; display: flex;">
            <!-- Left: File Explorer -->
            <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
              <h3 style="margin: 0 0 5px 0; border-bottom: 1px solid black;">File Explorer</h3>
              <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">
                     <strong>src</strong><ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">hello-world.js</li></ul></li></ul>
            </div>
            <!-- Right: Editor -->
            <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column;">
              <!-- Editor Tabs -->
              <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
                
        <div style="
            padding: 2px 5px;
            border: 1px solid black;
            margin-right: 5px;
            background: #ddd;
            display: inline-block;
            ">
          src/hello-world.js <span style="color: green;">•</span>
        </div>
              </div>
              <!-- Editor Content -->
              <div style="flex: 1; padding: 5px; overflow: auto;">
                <pre style="margin:0;">console.log('Hello, world!');</pre>
              </div>
            </div>
          </div>
          <!-- Bottom: Terminal -->
          <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
            <div style="font-weight: bold;">codevideo &gt; </div>
            <pre style="margin:0;"></pre>
          </div>
        </div>
      </body>
    </html>
    "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 8 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;"><strong>src</strong><ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">hello-world.js</li></ul></li></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        src/hello-world.js <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">console.log('Hello, world!');</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Let's open up hello-world.js now...
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 8 (terminal-type) 1`] = `
"
    <!DOCTYPE html>
    <html>
      <head>
        <meta charset="UTF-8">
        <title>VirtualIDE Snapshot</title>
      </head>
      <body style="margin:0; padding:0; font-family: monospace;">
        <div style="display: flex; flex-direction: column; height: 100vh;">
          <!-- Main IDE Area -->
          <div style="flex: 1; display: flex;">
            <!-- Left: File Explorer -->
            <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
              <h3 style="margin: 0 0 5px 0; border-bottom: 1px solid black;">File Explorer</h3>
              <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">
                     <strong>src</strong><ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">hello-world.js</li></ul></li></ul>
            </div>
            <!-- Right: Editor -->
            <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column;">
              <!-- Editor Tabs -->
              <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
                
        <div style="
            padding: 2px 5px;
            border: 1px solid black;
            margin-right: 5px;
            background: #ddd;
            display: inline-block;
            ">
          src/hello-world.js <span style="color: green;">•</span>
        </div>
              </div>
              <!-- Editor Content -->
              <div style="flex: 1; padding: 5px; overflow: auto;">
                <pre style="margin:0;">console.log('Hello, world!');</pre>
              </div>
            </div>
          </div>
          <!-- Bottom: Terminal -->
          <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
            <div style="font-weight: bold;">codevideo &gt; </div>
            <pre style="margin:0;">node src/hello-world.js</pre>
          </div>
        </div>
      </body>
    </html>
    "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 9 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Let's start by looking at the problem. We need to simulate some strange stones that change every time we blink...
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 9 (editor-save) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;"><strong>src</strong><ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">hello-world.js</li></ul></li></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        src/hello-world.js <span style="color: green;">•</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">console.log('Hello, world!');</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Let's open up hello-world.js now...
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 9 (terminal-enter) 1`] = `
"
    <!DOCTYPE html>
    <html>
      <head>
        <meta charset="UTF-8">
        <title>VirtualIDE Snapshot</title>
      </head>
      <body style="margin:0; padding:0; font-family: monospace;">
        <div style="display: flex; flex-direction: column; height: 100vh;">
          <!-- Main IDE Area -->
          <div style="flex: 1; display: flex;">
            <!-- Left: File Explorer -->
            <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
              <h3 style="margin: 0 0 5px 0; border-bottom: 1px solid black;">File Explorer</h3>
              <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">
                     <strong>src</strong><ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">hello-world.js</li></ul></li></ul>
            </div>
            <!-- Right: Editor -->
            <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column;">
              <!-- Editor Tabs -->
              <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
                
        <div style="
            padding: 2px 5px;
            border: 1px solid black;
            margin-right: 5px;
            background: #ddd;
            display: inline-block;
            ">
          src/hello-world.js <span style="color: green;">•</span>
        </div>
              </div>
              <!-- Editor Content -->
              <div style="flex: 1; padding: 5px; overflow: auto;">
                <pre style="margin:0;">console.log('Hello, world!');</pre>
              </div>
            </div>
          </div>
          <!-- Bottom: Terminal -->
          <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
            <div style="font-weight: bold;">codevideo &gt; </div>
            <pre style="margin:0;"></pre>
          </div>
        </div>
      </body>
    </html>
    "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 10 (author-speak-before) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;"><strong>src</strong><ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">hello-world.js</li></ul></li></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        src/hello-world.js <span style="color: green;">•</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">console.log('Hello, world!');</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Now we'll open up a terminal and run this file.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 10 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Let's start by looking at the problem. We need to simulate some strange stones that change every time we blink...
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 11 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Let's start by looking at the problem. We need to simulate some strange stones that change every time we blink...
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 11 (terminal-open) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;"><strong>src</strong><ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">hello-world.js</li></ul></li></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        src/hello-world.js <span style="color: green;">•</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">console.log('Hello, world!');</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Now we'll open up a terminal and run this file.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 12 (author-speak-before) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      The rules are pretty straightforward. For each stone, we need to check three conditions...
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 12 (editor-type) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Let's start by looking at the problem. We need to simulate some strange stones that change every time we blink...
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 12 (mouse-click-terminal) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;"><strong>src</strong><ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">hello-world.js</li></ul></li></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        src/hello-world.js <span style="color: green;">•</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">console.log('Hello, world!');</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Now we'll open up a terminal and run this file.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 13 (editor-enter) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Let's start by looking at the problem. We need to simulate some strange stones that change every time we blink...
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 13 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      The rules are pretty straightforward. For each stone, we need to check three conditions...
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 13 (terminal-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;"><strong>src</strong><ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">hello-world.js</li></ul></li></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        src/hello-world.js <span style="color: green;">•</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">console.log('Hello, world!');</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Now we'll open up a terminal and run this file.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;">node src/hello-world.js</pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 14 (author-speak-before) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      The rules are pretty straightforward. For each stone, we need to check three conditions...
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 14 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      The rules are pretty straightforward. For each stone, we need to check three conditions...
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 14 (terminal-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;"><strong>src</strong><ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">hello-world.js</li></ul></li></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        src/hello-world.js <span style="color: green;">•</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">console.log('Hello, world!');</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Now we'll open up a terminal and run this file.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 15 (author-speak-before) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;"><strong>src</strong><ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">hello-world.js</li></ul></li></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        src/hello-world.js <span style="color: green;">•</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">console.log('Hello, world!');</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Let's create a utilities module for our logger.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 15 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      The rules are pretty straightforward. For each stone, we need to check three conditions...
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 16 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      The rules are pretty straightforward. For each stone, we need to check three conditions...
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 16 (file-explorer-create-folder) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;"><strong>src</strong><ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">hello-world.js</li><li style="margin: 2px 0;"><strong>utils</strong><ul style='list-style: none; padding-left: 10px; margin: 0;'></ul></li></ul></li></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        src/hello-world.js <span style="color: green;">•</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">console.log('Hello, world!');</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Let's create a utilities module for our logger.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 17 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      The rules are pretty straightforward. For each stone, we need to check three conditions...
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 17 (file-explorer-create-file) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;"><strong>src</strong><ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">hello-world.js</li><li style="margin: 2px 0;"><strong>utils</strong><ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">logger.js</li></ul></li></ul></li></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        src/hello-world.js <span style="color: green;">•</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">console.log('Hello, world!');</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Let's create a utilities module for our logger.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 18 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      The rules are pretty straightforward. For each stone, we need to check three conditions...
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 18 (file-explorer-open-file) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;"><strong>src</strong><ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">hello-world.js</li><li style="margin: 2px 0;"><strong>utils</strong><ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">logger.js</li></ul></li></ul></li></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        src/hello-world.js <span style="color: green;">•</span>
      </div>
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #fff;
          display: inline-block;">
        src/utils/logger.js <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">console.log('Hello, world!');</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Let's create a utilities module for our logger.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 19 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      The rules are pretty straightforward. For each stone, we need to check three conditions...
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 19 (mouse-click-editor) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;"><strong>src</strong><ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">hello-world.js</li><li style="margin: 2px 0;"><strong>utils</strong><ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">logger.js</li></ul></li></ul></li></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        src/hello-world.js <span style="color: green;">•</span>
      </div>
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #fff;
          display: inline-block;">
        src/utils/logger.js <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">console.log('Hello, world!');</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Let's create a utilities module for our logger.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 20 (author-speak-before) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      So here it's pretty straightforward, if the stone is engraved with 0 it becomes engraved with a 1
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 20 (editor-enter) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      The rules are pretty straightforward. For each stone, we need to check three conditions...
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 20 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;"><strong>src</strong><ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">hello-world.js</li><li style="margin: 2px 0;"><strong>utils</strong><ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">logger.js</li></ul></li></ul></li></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        src/hello-world.js <span style="color: green;">•</span>
      </div>
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #fff;
          display: inline-block;">
        src/utils/logger.js <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">console.log('Hello, world!');</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Let's create a utilities module for our logger.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 21 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      So here it's pretty straightforward, if the stone is engraved with 0 it becomes engraved with a 1
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 21 (editor-save) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;"><strong>src</strong><ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">hello-world.js</li><li style="margin: 2px 0;"><strong>utils</strong><ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">logger.js</li></ul></li></ul></li></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        src/hello-world.js <span style="color: green;">•</span>
      </div>
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #fff;
          display: inline-block;">
        src/utils/logger.js <span style="color: green;">•</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">console.log('Hello, world!');</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Let's create a utilities module for our logger.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 21 (editor-type) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      The rules are pretty straightforward. For each stone, we need to check three conditions...
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 22 (author-speak-before) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      So here it's pretty straightforward, if the stone is engraved with 0 it becomes engraved with a 1
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 22 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      So here it's pretty straightforward, if the stone is engraved with 0 it becomes engraved with a 1
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 22 (mouse-click-filename) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;"><strong>src</strong><ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">hello-world.js</li><li style="margin: 2px 0;"><strong>utils</strong><ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">logger.js</li></ul></li></ul></li></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        src/hello-world.js <span style="color: green;">•</span>
      </div>
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #fff;
          display: inline-block;">
        src/utils/logger.js <span style="color: green;">•</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">console.log('Hello, world!');</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Let's create a utilities module for our logger.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 23 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      So here it's pretty straightforward, if the stone is engraved with 0 it becomes engraved with a 1
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 23 (mouse-click-editor) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;"><strong>src</strong><ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">hello-world.js</li><li style="margin: 2px 0;"><strong>utils</strong><ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">logger.js</li></ul></li></ul></li></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        src/hello-world.js <span style="color: green;">•</span>
      </div>
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #fff;
          display: inline-block;">
        src/utils/logger.js <span style="color: green;">•</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">console.log('Hello, world!');</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Let's create a utilities module for our logger.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 24 (editor-backspace) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;"><strong>src</strong><ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">hello-world.js</li><li style="margin: 2px 0;"><strong>utils</strong><ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">logger.js</li></ul></li></ul></li></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        src/hello-world.js <span style="color: red;">x</span>
      </div>
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #fff;
          display: inline-block;">
        src/utils/logger.js <span style="color: green;">•</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;"></pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Let's create a utilities module for our logger.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 24 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      So here it's pretty straightforward, if the stone is engraved with 0 it becomes engraved with a 1
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 25 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      So here it's pretty straightforward, if the stone is engraved with 0 it becomes engraved with a 1
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 25 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;"><strong>src</strong><ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">hello-world.js</li><li style="margin: 2px 0;"><strong>utils</strong><ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">logger.js</li></ul></li></ul></li></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        src/hello-world.js <span style="color: red;">x</span>
      </div>
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #fff;
          display: inline-block;">
        src/utils/logger.js <span style="color: green;">•</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">const { log } = require('./utils/logger');

log('Hello, world!');</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Let's create a utilities module for our logger.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 26 (editor-save) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;"><strong>src</strong><ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">hello-world.js</li><li style="margin: 2px 0;"><strong>utils</strong><ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">logger.js</li></ul></li></ul></li></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        src/hello-world.js <span style="color: green;">•</span>
      </div>
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #fff;
          display: inline-block;">
        src/utils/logger.js <span style="color: green;">•</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">const { log } = require('./utils/logger');

log('Hello, world!');</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Let's create a utilities module for our logger.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 26 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      So here it's pretty straightforward, if the stone is engraved with 0 it becomes engraved with a 1
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 27 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      So here it's pretty straightforward, if the stone is engraved with 0 it becomes engraved with a 1
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 27 (mouse-click-terminal) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;"><strong>src</strong><ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">hello-world.js</li><li style="margin: 2px 0;"><strong>utils</strong><ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">logger.js</li></ul></li></ul></li></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        src/hello-world.js <span style="color: green;">•</span>
      </div>
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #fff;
          display: inline-block;">
        src/utils/logger.js <span style="color: green;">•</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">const { log } = require('./utils/logger');

log('Hello, world!');</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Let's create a utilities module for our logger.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 28 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      So here it's pretty straightforward, if the stone is engraved with 0 it becomes engraved with a 1
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 28 (terminal-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;"><strong>src</strong><ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">hello-world.js</li><li style="margin: 2px 0;"><strong>utils</strong><ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">logger.js</li></ul></li></ul></li></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        src/hello-world.js <span style="color: green;">•</span>
      </div>
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #fff;
          display: inline-block;">
        src/utils/logger.js <span style="color: green;">•</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">const { log } = require('./utils/logger');

log('Hello, world!');</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Let's create a utilities module for our logger.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;">node src/hello-world.js</pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 29 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      So here it's pretty straightforward, if the stone is engraved with 0 it becomes engraved with a 1
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 30 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      So here it's pretty straightforward, if the stone is engraved with 0 it becomes engraved with a 1
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 31 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      So here it's pretty straightforward, if the stone is engraved with 0 it becomes engraved with a 1
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 32 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      So here it's pretty straightforward, if the stone is engraved with 0 it becomes engraved with a 1
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 33 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      So here it's pretty straightforward, if the stone is engraved with 0 it becomes engraved with a 1
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 34 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      So here it's pretty straightforward, if the stone is engraved with 0 it becomes engraved with a 1
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 35 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      So here it's pretty straightforward, if the stone is engraved with 0 it becomes engraved with a 1
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 36 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      So here it's pretty straightforward, if the stone is engraved with 0 it becomes engraved with a 1
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 37 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      So here it's pretty straightforward, if the stone is engraved with 0 it becomes engraved with a 1
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 38 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      So here it's pretty straightforward, if the stone is engraved with 0 it becomes engraved with a 1
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 39 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      So here it's pretty straightforward, if the stone is engraved with 0 it becomes engraved with a 1
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 40 (author-speak-before) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      And for this else block, if a stone has an even number of digits, we split it in two where the "left" stone becomes the first half of the original stone, and the right stone becomes the "right" half of the original stone.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 40 (editor-type) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      So here it's pretty straightforward, if the stone is engraved with 0 it becomes engraved with a 1
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 41 (editor-enter) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      So here it's pretty straightforward, if the stone is engraved with 0 it becomes engraved with a 1
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 41 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      And for this else block, if a stone has an even number of digits, we split it in two where the "left" stone becomes the first half of the original stone, and the right stone becomes the "right" half of the original stone.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 42 (author-speak-before) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      And for this else block, if a stone has an even number of digits, we split it in two where the "left" stone becomes the first half of the original stone, and the right stone becomes the "right" half of the original stone.
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 42 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      And for this else block, if a stone has an even number of digits, we split it in two where the "left" stone becomes the first half of the original stone, and the right stone becomes the "right" half of the original stone.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 43 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      And for this else block, if a stone has an even number of digits, we split it in two where the "left" stone becomes the first half of the original stone, and the right stone becomes the "right" half of the original stone.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 44 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      And for this else block, if a stone has an even number of digits, we split it in two where the "left" stone becomes the first half of the original stone, and the right stone becomes the "right" half of the original stone.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 45 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      And for this else block, if a stone has an even number of digits, we split it in two where the "left" stone becomes the first half of the original stone, and the right stone becomes the "right" half of the original stone.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 46 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      And for this else block, if a stone has an even number of digits, we split it in two where the "left" stone becomes the first half of the original stone, and the right stone becomes the "right" half of the original stone.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 47 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      And for this else block, if a stone has an even number of digits, we split it in two where the "left" stone becomes the first half of the original stone, and the right stone becomes the "right" half of the original stone.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 48 (author-speak-before) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      And finally, if none of the other rules applied, we multiply the stone by 2024
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 48 (editor-enter) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      And for this else block, if a stone has an even number of digits, we split it in two where the "left" stone becomes the first half of the original stone, and the right stone becomes the "right" half of the original stone.
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 49 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      And finally, if none of the other rules applied, we multiply the stone by 2024
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 49 (editor-type) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      And for this else block, if a stone has an even number of digits, we split it in two where the "left" stone becomes the first half of the original stone, and the right stone becomes the "right" half of the original stone.
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 50 (author-speak-before) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      And finally, if none of the other rules applied, we multiply the stone by 2024
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 50 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      And finally, if none of the other rules applied, we multiply the stone by 2024
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 51 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      And finally, if none of the other rules applied, we multiply the stone by 2024
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 52 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      And finally, if none of the other rules applied, we multiply the stone by 2024
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 53 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      And finally, if none of the other rules applied, we multiply the stone by 2024
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 54 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      And finally, if none of the other rules applied, we multiply the stone by 2024
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 55 (author-speak-before) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      And then of course we return the new stones.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 55 (editor-enter) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      And finally, if none of the other rules applied, we multiply the stone by 2024
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 56 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      And then of course we return the new stones.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 56 (editor-type) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      And finally, if none of the other rules applied, we multiply the stone by 2024
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 57 (author-speak-before) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      And then of course we return the new stones.
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 57 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      And then of course we return the new stones.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 58 (author-speak-before) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      This naive implementation works fine for Part 1, where we only need to blink 25 times. Lets set up a part 1 function and run it.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 58 (editor-enter) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      And then of course we return the new stones.
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 59 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      This naive implementation works fine for Part 1, where we only need to blink 25 times. Lets set up a part 1 function and run it.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 59 (editor-type) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      And then of course we return the new stones.
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 60 (author-speak-before) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      This naive implementation works fine for Part 1, where we only need to blink 25 times. Lets set up a part 1 function and run it.
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 60 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      This naive implementation works fine for Part 1, where we only need to blink 25 times. Lets set up a part 1 function and run it.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 61 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      This naive implementation works fine for Part 1, where we only need to blink 25 times. Lets set up a part 1 function and run it.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 62 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      This naive implementation works fine for Part 1, where we only need to blink 25 times. Lets set up a part 1 function and run it.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 63 (author-speak-before) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We'll read in the single line puzzle input as an array.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 63 (editor-enter) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      This naive implementation works fine for Part 1, where we only need to blink 25 times. Lets set up a part 1 function and run it.
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 64 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We'll read in the single line puzzle input as an array.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 64 (editor-type) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      This naive implementation works fine for Part 1, where we only need to blink 25 times. Lets set up a part 1 function and run it.
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 65 (author-speak-before) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We'll read in the single line puzzle input as an array.
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 65 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We'll read in the single line puzzle input as an array.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 66 (author-speak-before) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Then convert that first array to a vec of 64 byte integers.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 66 (editor-enter) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We'll read in the single line puzzle input as an array.
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 67 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Then convert that first array to a vec of 64 byte integers.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 67 (editor-type) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We'll read in the single line puzzle input as an array.
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 68 (author-speak-before) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Then convert that first array to a vec of 64 byte integers.
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 68 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Then convert that first array to a vec of 64 byte integers.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 69 (author-speak-before) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We'll make a mutable clone of the initial stone engravings.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 69 (editor-enter) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Then convert that first array to a vec of 64 byte integers.
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 70 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We'll make a mutable clone of the initial stone engravings.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 70 (editor-type) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Then convert that first array to a vec of 64 byte integers.
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 71 (author-speak-before) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We'll make a mutable clone of the initial stone engravings.
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 71 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We'll make a mutable clone of the initial stone engravings.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 72 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We'll make a mutable clone of the initial stone engravings.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 73 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We'll make a mutable clone of the initial stone engravings.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 74 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We'll make a mutable clone of the initial stone engravings.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 75 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We'll make a mutable clone of the initial stone engravings.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 76 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We'll make a mutable clone of the initial stone engravings.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 77 (author-speak-before) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      And then we can execute the blink 25 times!
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 77 (editor-type) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We'll make a mutable clone of the initial stone engravings.
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 78 (author-speak-before) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We can then finally log out the solution.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 78 (editor-enter) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We'll make a mutable clone of the initial stone engravings.
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 79 (author-speak-before) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      And then we can execute the blink 25 times!
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 79 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We can then finally log out the solution.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 80 (author-speak-before) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We can then finally log out the solution.
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 80 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We can then finally log out the solution.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 81 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We can then finally log out the solution.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 82 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We can then finally log out the solution.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 83 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We can then finally log out the solution.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 84 (author-speak-before) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Now, we could have just pasted in the puzzle input directly and converted to an array, but that's not so elegant, so let's go up to the top of the file and implement this read lines as int arrays function.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 84 (editor-enter) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We can then finally log out the solution.
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 85 (editor-arrow-up) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Now, we could have just pasted in the puzzle input directly and converted to an array, but that's not so elegant, so let's go up to the top of the file and implement this read lines as int arrays function.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 85 (editor-type) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We can then finally log out the solution.
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 86 (author-speak-before) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Now, we could have just pasted in the puzzle input directly and converted to an array, but that's not so elegant, so let's go up to the top of the file and implement this read lines as int arrays function.
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 86 (editor-arrow-left) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Now, we could have just pasted in the puzzle input directly and converted to an array, but that's not so elegant, so let's go up to the top of the file and implement this read lines as int arrays function.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 87 (editor-arrow-up) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Now, we could have just pasted in the puzzle input directly and converted to an array, but that's not so elegant, so let's go up to the top of the file and implement this read lines as int arrays function.
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 87 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">


// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Now, we could have just pasted in the puzzle input directly and converted to an array, but that's not so elegant, so let's go up to the top of the file and implement this read lines as int arrays function.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 88 (editor-arrow-left) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Now, we could have just pasted in the puzzle input directly and converted to an array, but that's not so elegant, so let's go up to the top of the file and implement this read lines as int arrays function.
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 88 (editor-arrow-up) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">


// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Now, we could have just pasted in the puzzle input directly and converted to an array, but that's not so elegant, so let's go up to the top of the file and implement this read lines as int arrays function.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 89 (author-speak-before) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">


// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We need to import from fs, io, and path libraries.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 89 (editor-enter) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">


// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Now, we could have just pasted in the puzzle input directly and converted to an array, but that's not so elegant, so let's go up to the top of the file and implement this read lines as int arrays function.
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 90 (editor-arrow-up) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">


// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Now, we could have just pasted in the puzzle input directly and converted to an array, but that's not so elegant, so let's go up to the top of the file and implement this read lines as int arrays function.
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 90 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::fs::File;


// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We need to import from fs, io, and path libraries.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 91 (author-speak-before) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">


// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We need to import from fs, io, and path libraries.
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 91 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::fs::File;



// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We need to import from fs, io, and path libraries.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 92 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::fs::File;
use std::io::{self, BufRead, BufReader};


// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We need to import from fs, io, and path libraries.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 93 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::fs::File;
use std::io::{self, BufRead, BufReader};



// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We need to import from fs, io, and path libraries.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 94 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;


// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We need to import from fs, io, and path libraries.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 95 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We need to import from fs, io, and path libraries.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 96 (author-speak-before) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We'll start by importing the necessary modules. We need File for opening files, io utilities for buffered reading, and Path for handling file paths.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 96 (editor-type) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;


// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We need to import from fs, io, and path libraries.
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 97 (editor-enter) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We need to import from fs, io, and path libraries.
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 97 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>


// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We'll start by importing the necessary modules. We need File for opening files, io utilities for buffered reading, and Path for handling file paths.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 98 (author-speak-before) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We'll start by importing the necessary modules. We need File for opening files, io utilities for buffered reading, and Path for handling file paths.
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 98 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>



// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We'll start by importing the necessary modules. We need File for opening files, io utilities for buffered reading, and Path for handling file paths.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 99 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where


// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We'll start by importing the necessary modules. We need File for opening files, io utilities for buffered reading, and Path for handling file paths.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 100 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where



// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We'll start by importing the necessary modules. We need File for opening files, io utilities for buffered reading, and Path for handling file paths.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 101 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,


// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We'll start by importing the necessary modules. We need File for opening files, io utilities for buffered reading, and Path for handling file paths.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 102 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,



// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We'll start by importing the necessary modules. We need File for opening files, io utilities for buffered reading, and Path for handling file paths.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 103 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{


// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We'll start by importing the necessary modules. We need File for opening files, io utilities for buffered reading, and Path for handling file paths.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 104 (author-speak-before) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{


// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Our function will be generic over any type P that can be referenced as a Path. This gives us flexibility in what types of path arguments we can accept.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 104 (editor-enter) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,



// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We'll start by importing the necessary modules. We need File for opening files, io utilities for buffered reading, and Path for handling file paths.
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 105 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{



// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Our function will be generic over any type P that can be referenced as a Path. This gives us flexibility in what types of path arguments we can accept.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 105 (editor-type) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{


// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We'll start by importing the necessary modules. We need File for opening files, io utilities for buffered reading, and Path for handling file paths.
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 106 (author-speak-before) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{


// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Our function will be generic over any type P that can be referenced as a Path. This gives us flexibility in what types of path arguments we can accept.
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 106 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;


// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Our function will be generic over any type P that can be referenced as a Path. This gives us flexibility in what types of path arguments we can accept.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 107 (author-speak-before) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;


// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We open the file using the question mark operator, which will return early with an error if the file can't be opened.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 107 (editor-enter) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{



// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Our function will be generic over any type P that can be referenced as a Path. This gives us flexibility in what types of path arguments we can accept.
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 108 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;



// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We open the file using the question mark operator, which will return early with an error if the file can't be opened.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 108 (editor-type) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;


// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Our function will be generic over any type P that can be referenced as a Path. This gives us flexibility in what types of path arguments we can accept.
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 109 (author-speak-before) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;


// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We open the file using the question mark operator, which will return early with an error if the file can't be opened.
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 109 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);


// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We open the file using the question mark operator, which will return early with an error if the file can't be opened.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 110 (author-speak-before) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);


// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We wrap the file in a BufReader for efficient reading. This gives us buffered reading capabilities which are much more efficient than reading one byte at a time.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 110 (editor-enter) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;



// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We open the file using the question mark operator, which will return early with an error if the file can't be opened.
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 111 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);



// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We wrap the file in a BufReader for efficient reading. This gives us buffered reading capabilities which are much more efficient than reading one byte at a time.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 111 (editor-type) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);


// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We open the file using the question mark operator, which will return early with an error if the file can't be opened.
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 112 (author-speak-before) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);


// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We wrap the file in a BufReader for efficient reading. This gives us buffered reading capabilities which are much more efficient than reading one byte at a time.
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 112 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();


// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We wrap the file in a BufReader for efficient reading. This gives us buffered reading capabilities which are much more efficient than reading one byte at a time.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 113 (author-speak-before) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();


// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We collect all lines into a vector. Note that each line is actually a Result, since reading can fail at any point.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 113 (editor-enter) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);



// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We wrap the file in a BufReader for efficient reading. This gives us buffered reading capabilities which are much more efficient than reading one byte at a time.
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 114 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();



// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We collect all lines into a vector. Note that each line is actually a Result, since reading can fail at any point.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 114 (editor-type) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();


// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We wrap the file in a BufReader for efficient reading. This gives us buffered reading capabilities which are much more efficient than reading one byte at a time.
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 115 (author-speak-before) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();


// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We collect all lines into a vector. Note that each line is actually a Result, since reading can fail at any point.
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 115 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();


// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We collect all lines into a vector. Note that each line is actually a Result, since reading can fail at any point.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 116 (author-speak-before) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();


// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We'll create a vector to store our processed integer arrays.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 116 (editor-enter) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();



// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We collect all lines into a vector. Note that each line is actually a Result, since reading can fail at any point.
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 117 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();



// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We'll create a vector to store our processed integer arrays.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 117 (editor-type) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();


// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We collect all lines into a vector. Note that each line is actually a Result, since reading can fail at any point.
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 118 (author-speak-before) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();


// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We'll create a vector to store our processed integer arrays.
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 118 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer


// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We'll create a vector to store our processed integer arrays.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 119 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer



// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We'll create a vector to store our processed integer arrays.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 120 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {


// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We'll create a vector to store our processed integer arrays.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 121 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {



// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We'll create a vector to store our processed integer arrays.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 122 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;


// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We'll create a vector to store our processed integer arrays.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 123 (author-speak-before) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;


// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      For each line, we use the question mark operator to handle any potential reading errors.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 123 (editor-enter) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {



// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We'll create a vector to store our processed integer arrays.
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 124 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;



// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      For each line, we use the question mark operator to handle any potential reading errors.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 124 (editor-type) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;


// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We'll create a vector to store our processed integer arrays.
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 125 (author-speak-before) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;


// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      For each line, we use the question mark operator to handle any potential reading errors.
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 125 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();


// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      For each line, we use the question mark operator to handle any potential reading errors.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 126 (author-speak-before) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();


// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We split each line by the separator, then parse each piece into an integer. Note that we're using unwrap here, which means this function will panic if it encounters any non-integer values.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 126 (editor-enter) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;



// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      For each line, we use the question mark operator to handle any potential reading errors.
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 127 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();



// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We split each line by the separator, then parse each piece into an integer. Note that we're using unwrap here, which means this function will panic if it encounters any non-integer values.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 127 (editor-type) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();


// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      For each line, we use the question mark operator to handle any potential reading errors.
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 128 (author-speak-before) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();


// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We split each line by the separator, then parse each piece into an integer. Note that we're using unwrap here, which means this function will panic if it encounters any non-integer values.
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 128 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);


// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We split each line by the separator, then parse each piece into an integer. Note that we're using unwrap here, which means this function will panic if it encounters any non-integer values.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 129 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);



// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We split each line by the separator, then parse each piece into an integer. Note that we're using unwrap here, which means this function will panic if it encounters any non-integer values.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 130 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }


// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We split each line by the separator, then parse each piece into an integer. Note that we're using unwrap here, which means this function will panic if it encounters any non-integer values.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 131 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }



// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We split each line by the separator, then parse each piece into an integer. Note that we're using unwrap here, which means this function will panic if it encounters any non-integer values.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 132 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)


// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We split each line by the separator, then parse each piece into an integer. Note that we're using unwrap here, which means this function will panic if it encounters any non-integer values.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 133 (author-speak-before) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)


// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Finally, we wrap our vector of integer arrays in Ok and return it.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 133 (editor-enter) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }



// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We split each line by the separator, then parse each piece into an integer. Note that we're using unwrap here, which means this function will panic if it encounters any non-integer values.
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 134 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)



// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Finally, we wrap our vector of integer arrays in Ok and return it.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 134 (editor-type) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)


// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We split each line by the separator, then parse each piece into an integer. Note that we're using unwrap here, which means this function will panic if it encounters any non-integer values.
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 135 (author-speak-before) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)


// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Finally, we wrap our vector of integer arrays in Ok and return it.
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 135 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}


// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Finally, we wrap our vector of integer arrays in Ok and return it.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 136 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Finally, we wrap our vector of integer arrays in Ok and return it.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 137 (author-speak-before) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We'll create a main function to call the run part one function.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 137 (editor-type) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}


// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Finally, we wrap our vector of integer arrays in Ok and return it.
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 138 (editor-enter) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Finally, we wrap our vector of integer arrays in Ok and return it.
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 138 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {


// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We'll create a main function to call the run part one function.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 139 (author-speak-before) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We'll create a main function to call the run part one function.
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 139 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {



// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We'll create a main function to call the run part one function.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 140 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();


// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We'll create a main function to call the run part one function.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 141 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();



// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We'll create a main function to call the run part one function.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 142 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}


// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We'll create a main function to call the run part one function.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 143 (author-speak-before) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}


// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      And let's run this with cargo run:
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 143 (editor-enter) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();



// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We'll create a main function to call the run part one function.
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 144 (editor-type) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}


// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We'll create a main function to call the run part one function.
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 144 (mouse-click-terminal) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}


// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      And let's run this with cargo run:
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 145 (author-speak-before) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}


// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      And let's run this with cargo run:
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 145 (terminal-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}


// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      And let's run this with cargo run:
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;">cargo run</pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 146 (mouse-click-terminal) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}


// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      And let's run this with cargo run:
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 146 (terminal-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}


// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      And let's run this with cargo run:
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 147 (mouse-click-editor) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}


// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      And let's run this with cargo run:
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 147 (terminal-type) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}


// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      And let's run this with cargo run:
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript">cargo run</code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 148 (author-speak-before) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}


// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      However, when we try to use this approach for Part 2, which requires 75 blinks, we run into quite a problem. The number of stones grows exponentially the more we blink, and even when I was running this on my own M3 Max Mac, the calculations becomes intractable after around 40 to 45 blinks.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 148 (terminal-enter) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}


// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      And let's run this with cargo run:
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 149 (author-speak-before) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}


// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      It's time we implement a more elegant, optimized, and efficient solution using recursion and memoization.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 149 (mouse-click-editor) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}


// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      And let's run this with cargo run:
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 150 (author-speak-before) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}


// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      However, when we try to use this approach for Part 2, which requires 75 blinks, we run into quite a problem. The number of stones grows exponentially the more we blink, and even when I was running this on my own M3 Max Mac, the calculations becomes intractable after around 40 to 45 blinks.
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 150 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      It's time we implement a more elegant, optimized, and efficient solution using recursion and memoization.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 151 (author-speak-before) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Let's get started by going to the top of the file and importing the HashMap package. We'll need this to keep track of our memoized stone engravings.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 152 (editor-arrow-up) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Let's get started by going to the top of the file and importing the HashMap package. We'll need this to keep track of our memoized stone engravings.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 152 (editor-enter) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      It's time we implement a more elegant, optimized, and efficient solution using recursion and memoization.
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 153 (author-speak-before) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Let's get started by going to the top of the file and importing the HashMap package. We'll need this to keep track of our memoized stone engravings.
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 153 (editor-command-left) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Let's get started by going to the top of the file and importing the HashMap package. We'll need this to keep track of our memoized stone engravings.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 154 (editor-arrow-up) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Let's get started by going to the top of the file and importing the HashMap package. We'll need this to keep track of our memoized stone engravings.
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 154 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Let's get started by going to the top of the file and importing the HashMap package. We'll need this to keep track of our memoized stone engravings.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 155 (editor-arrow-up) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Let's get started by going to the top of the file and importing the HashMap package. We'll need this to keep track of our memoized stone engravings.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 155 (editor-command-left) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Let's get started by going to the top of the file and importing the HashMap package. We'll need this to keep track of our memoized stone engravings.
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 156 (editor-enter) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Let's get started by going to the top of the file and importing the HashMap package. We'll need this to keep track of our memoized stone engravings.
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 156 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Let's get started by going to the top of the file and importing the HashMap package. We'll need this to keep track of our memoized stone engravings.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 157 (editor-arrow-down) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Let's get started by going to the top of the file and importing the HashMap package. We'll need this to keep track of our memoized stone engravings.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 157 (editor-arrow-up) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Let's get started by going to the top of the file and importing the HashMap package. We'll need this to keep track of our memoized stone engravings.
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 158 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;



fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Let's get started by going to the top of the file and importing the HashMap package. We'll need this to keep track of our memoized stone engravings.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 158 (editor-type) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Let's get started by going to the top of the file and importing the HashMap package. We'll need this to keep track of our memoized stone engravings.
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 159 (editor-arrow-down) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Let's get started by going to the top of the file and importing the HashMap package. We'll need this to keep track of our memoized stone engravings.
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 159 (editor-arrow-up) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;



fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Let's get started by going to the top of the file and importing the HashMap package. We'll need this to keep track of our memoized stone engravings.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 160 (author-speak-before) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;



fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We can then define MemoKey and MemoMap types.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 160 (editor-enter) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;



fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Let's get started by going to the top of the file and importing the HashMap package. We'll need this to keep track of our memoized stone engravings.
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 161 (editor-arrow-up) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;



fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Let's get started by going to the top of the file and importing the HashMap package. We'll need this to keep track of our memoized stone engravings.
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 161 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We can then define MemoKey and MemoMap types.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 162 (author-speak-before) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;



fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We can then define MemoKey and MemoMap types.
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 162 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)


fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We can then define MemoKey and MemoMap types.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 163 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We can then define MemoKey and MemoMap types.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 164 (author-speak-before) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      The reason we can memoize according to blinks is because the resulting stone from any given stone will always be the same - you can take a given stone, whether it be 0, 1, 2, 3 or whatever - and you immediately know any other stone you see from that point on will have the same exact 'production' of further stones... so to speak.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 164 (editor-enter) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)


fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We can then define MemoKey and MemoMap types.
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 165 (editor-arrow-down) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      The reason we can memoize according to blinks is because the resulting stone from any given stone will always be the same - you can take a given stone, whether it be 0, 1, 2, 3 or whatever - and you immediately know any other stone you see from that point on will have the same exact 'production' of further stones... so to speak.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 165 (editor-type) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We can then define MemoKey and MemoMap types.
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 166 (author-speak-before) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      The reason we can memoize according to blinks is because the resulting stone from any given stone will always be the same - you can take a given stone, whether it be 0, 1, 2, 3 or whatever - and you immediately know any other stone you see from that point on will have the same exact 'production' of further stones... so to speak.
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 166 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}
</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      The reason we can memoize according to blinks is because the resulting stone from any given stone will always be the same - you can take a given stone, whether it be 0, 1, 2, 3 or whatever - and you immediately know any other stone you see from that point on will have the same exact 'production' of further stones... so to speak.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 167 (author-speak-before) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}
</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      So let's get started with the implementation.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 167 (editor-arrow-down) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      The reason we can memoize according to blinks is because the resulting stone from any given stone will always be the same - you can take a given stone, whether it be 0, 1, 2, 3 or whatever - and you immediately know any other stone you see from that point on will have the same exact 'production' of further stones... so to speak.
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 168 (editor-enter) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}
</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      The reason we can memoize according to blinks is because the resulting stone from any given stone will always be the same - you can take a given stone, whether it be 0, 1, 2, 3 or whatever - and you immediately know any other stone you see from that point on will have the same exact 'production' of further stones... so to speak.
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 168 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      So let's get started with the implementation.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 169 (author-speak-before) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      This new function will take the current stone engraving we are looking at, the number of blinks we are at, and the memoized map of stone engraving and blinks remaining.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 170 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      This new function will take the current stone engraving we are looking at, the number of blinks we are at, and the memoized map of stone engraving and blinks remaining.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 170 (editor-type) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      So let's get started with the implementation.
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 171 (author-speak-before) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      This new function will take the current stone engraving we are looking at, the number of blinks we are at, and the memoized map of stone engraving and blinks remaining.
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 171 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      This new function will take the current stone engraving we are looking at, the number of blinks we are at, and the memoized map of stone engraving and blinks remaining.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 172 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      This new function will take the current stone engraving we are looking at, the number of blinks we are at, and the memoized map of stone engraving and blinks remaining.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 173 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      This new function will take the current stone engraving we are looking at, the number of blinks we are at, and the memoized map of stone engraving and blinks remaining.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 174 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      This new function will take the current stone engraving we are looking at, the number of blinks we are at, and the memoized map of stone engraving and blinks remaining.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 175 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      This new function will take the current stone engraving we are looking at, the number of blinks we are at, and the memoized map of stone engraving and blinks remaining.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 176 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      This new function will take the current stone engraving we are looking at, the number of blinks we are at, and the memoized map of stone engraving and blinks remaining.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 177 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      This new function will take the current stone engraving we are looking at, the number of blinks we are at, and the memoized map of stone engraving and blinks remaining.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 178 (author-speak-before) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      This is where a major optimization gain is - if we've already seen this stone and blinks combo, we can immediately return the count that this number of blinks results in for this stone!
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 178 (editor-enter) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      This new function will take the current stone engraving we are looking at, the number of blinks we are at, and the memoized map of stone engraving and blinks remaining.
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 179 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      This is where a major optimization gain is - if we've already seen this stone and blinks combo, we can immediately return the count that this number of blinks results in for this stone!
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 179 (editor-type) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      This new function will take the current stone engraving we are looking at, the number of blinks we are at, and the memoized map of stone engraving and blinks remaining.
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 180 (author-speak-before) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      This is where a major optimization gain is - if we've already seen this stone and blinks combo, we can immediately return the count that this number of blinks results in for this stone!
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 180 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      This is where a major optimization gain is - if we've already seen this stone and blinks combo, we can immediately return the count that this number of blinks results in for this stone!
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 181 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      This is where a major optimization gain is - if we've already seen this stone and blinks combo, we can immediately return the count that this number of blinks results in for this stone!
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 182 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      This is where a major optimization gain is - if we've already seen this stone and blinks combo, we can immediately return the count that this number of blinks results in for this stone!
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 183 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      This is where a major optimization gain is - if we've already seen this stone and blinks combo, we can immediately return the count that this number of blinks results in for this stone!
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 184 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      This is where a major optimization gain is - if we've already seen this stone and blinks combo, we can immediately return the count that this number of blinks results in for this stone!
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 185 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      This is where a major optimization gain is - if we've already seen this stone and blinks combo, we can immediately return the count that this number of blinks results in for this stone!
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 186 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      This is where a major optimization gain is - if we've already seen this stone and blinks combo, we can immediately return the count that this number of blinks results in for this stone!
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 187 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      This is where a major optimization gain is - if we've already seen this stone and blinks combo, we can immediately return the count that this number of blinks results in for this stone!
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 188 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      This is where a major optimization gain is - if we've already seen this stone and blinks combo, we can immediately return the count that this number of blinks results in for this stone!
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 189 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      This is where a major optimization gain is - if we've already seen this stone and blinks combo, we can immediately return the count that this number of blinks results in for this stone!
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 190 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      This is where a major optimization gain is - if we've already seen this stone and blinks combo, we can immediately return the count that this number of blinks results in for this stone!
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 191 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      This is where a major optimization gain is - if we've already seen this stone and blinks combo, we can immediately return the count that this number of blinks results in for this stone!
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 192 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      This is where a major optimization gain is - if we've already seen this stone and blinks combo, we can immediately return the count that this number of blinks results in for this stone!
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 193 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();
</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      This is where a major optimization gain is - if we've already seen this stone and blinks combo, we can immediately return the count that this number of blinks results in for this stone!
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 194 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();
            let right = stone_str[half..].parse::<i64>().unwrap();</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      This is where a major optimization gain is - if we've already seen this stone and blinks combo, we can immediately return the count that this number of blinks results in for this stone!
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 195 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();
            let right = stone_str[half..].parse::<i64>().unwrap();

</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      This is where a major optimization gain is - if we've already seen this stone and blinks combo, we can immediately return the count that this number of blinks results in for this stone!
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 196 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();
            let right = stone_str[half..].parse::<i64>().unwrap();

            count_stones_recursive(left, blinks - 1, memo) +</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      This is where a major optimization gain is - if we've already seen this stone and blinks combo, we can immediately return the count that this number of blinks results in for this stone!
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 197 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();
            let right = stone_str[half..].parse::<i64>().unwrap();

            count_stones_recursive(left, blinks - 1, memo) +
</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      This is where a major optimization gain is - if we've already seen this stone and blinks combo, we can immediately return the count that this number of blinks results in for this stone!
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 198 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();
            let right = stone_str[half..].parse::<i64>().unwrap();

            count_stones_recursive(left, blinks - 1, memo) +
            count_stones_recursive(right, blinks - 1, memo)</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      This is where a major optimization gain is - if we've already seen this stone and blinks combo, we can immediately return the count that this number of blinks results in for this stone!
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 199 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();
            let right = stone_str[half..].parse::<i64>().unwrap();

            count_stones_recursive(left, blinks - 1, memo) +
            count_stones_recursive(right, blinks - 1, memo)
</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      This is where a major optimization gain is - if we've already seen this stone and blinks combo, we can immediately return the count that this number of blinks results in for this stone!
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 200 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();
            let right = stone_str[half..].parse::<i64>().unwrap();

            count_stones_recursive(left, blinks - 1, memo) +
            count_stones_recursive(right, blinks - 1, memo)
        } else {</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      This is where a major optimization gain is - if we've already seen this stone and blinks combo, we can immediately return the count that this number of blinks results in for this stone!
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 201 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();
            let right = stone_str[half..].parse::<i64>().unwrap();

            count_stones_recursive(left, blinks - 1, memo) +
            count_stones_recursive(right, blinks - 1, memo)
        } else {
</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      This is where a major optimization gain is - if we've already seen this stone and blinks combo, we can immediately return the count that this number of blinks results in for this stone!
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 202 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();
            let right = stone_str[half..].parse::<i64>().unwrap();

            count_stones_recursive(left, blinks - 1, memo) +
            count_stones_recursive(right, blinks - 1, memo)
        } else {
            count_stones_recursive(stone * 2024, blinks - 1, memo)</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      This is where a major optimization gain is - if we've already seen this stone and blinks combo, we can immediately return the count that this number of blinks results in for this stone!
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 203 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();
            let right = stone_str[half..].parse::<i64>().unwrap();

            count_stones_recursive(left, blinks - 1, memo) +
            count_stones_recursive(right, blinks - 1, memo)
        } else {
            count_stones_recursive(stone * 2024, blinks - 1, memo)
</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      This is where a major optimization gain is - if we've already seen this stone and blinks combo, we can immediately return the count that this number of blinks results in for this stone!
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 204 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();
            let right = stone_str[half..].parse::<i64>().unwrap();

            count_stones_recursive(left, blinks - 1, memo) +
            count_stones_recursive(right, blinks - 1, memo)
        } else {
            count_stones_recursive(stone * 2024, blinks - 1, memo)
        }</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      This is where a major optimization gain is - if we've already seen this stone and blinks combo, we can immediately return the count that this number of blinks results in for this stone!
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 205 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();
            let right = stone_str[half..].parse::<i64>().unwrap();

            count_stones_recursive(left, blinks - 1, memo) +
            count_stones_recursive(right, blinks - 1, memo)
        } else {
            count_stones_recursive(stone * 2024, blinks - 1, memo)
        }
</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      This is where a major optimization gain is - if we've already seen this stone and blinks combo, we can immediately return the count that this number of blinks results in for this stone!
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 206 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();
            let right = stone_str[half..].parse::<i64>().unwrap();

            count_stones_recursive(left, blinks - 1, memo) +
            count_stones_recursive(right, blinks - 1, memo)
        } else {
            count_stones_recursive(stone * 2024, blinks - 1, memo)
        }
    };</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      This is where a major optimization gain is - if we've already seen this stone and blinks combo, we can immediately return the count that this number of blinks results in for this stone!
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 207 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();
            let right = stone_str[half..].parse::<i64>().unwrap();

            count_stones_recursive(left, blinks - 1, memo) +
            count_stones_recursive(right, blinks - 1, memo)
        } else {
            count_stones_recursive(stone * 2024, blinks - 1, memo)
        }
    };

</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      This is where a major optimization gain is - if we've already seen this stone and blinks combo, we can immediately return the count that this number of blinks results in for this stone!
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 208 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();
            let right = stone_str[half..].parse::<i64>().unwrap();

            count_stones_recursive(left, blinks - 1, memo) +
            count_stones_recursive(right, blinks - 1, memo)
        } else {
            count_stones_recursive(stone * 2024, blinks - 1, memo)
        }
    };

    memo.insert(key, result);</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      This is where a major optimization gain is - if we've already seen this stone and blinks combo, we can immediately return the count that this number of blinks results in for this stone!
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 209 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();
            let right = stone_str[half..].parse::<i64>().unwrap();

            count_stones_recursive(left, blinks - 1, memo) +
            count_stones_recursive(right, blinks - 1, memo)
        } else {
            count_stones_recursive(stone * 2024, blinks - 1, memo)
        }
    };

    memo.insert(key, result);
</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      This is where a major optimization gain is - if we've already seen this stone and blinks combo, we can immediately return the count that this number of blinks results in for this stone!
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 210 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();
            let right = stone_str[half..].parse::<i64>().unwrap();

            count_stones_recursive(left, blinks - 1, memo) +
            count_stones_recursive(right, blinks - 1, memo)
        } else {
            count_stones_recursive(stone * 2024, blinks - 1, memo)
        }
    };

    memo.insert(key, result);
    result</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      This is where a major optimization gain is - if we've already seen this stone and blinks combo, we can immediately return the count that this number of blinks results in for this stone!
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 211 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();
            let right = stone_str[half..].parse::<i64>().unwrap();

            count_stones_recursive(left, blinks - 1, memo) +
            count_stones_recursive(right, blinks - 1, memo)
        } else {
            count_stones_recursive(stone * 2024, blinks - 1, memo)
        }
    };

    memo.insert(key, result);
    result
</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      This is where a major optimization gain is - if we've already seen this stone and blinks combo, we can immediately return the count that this number of blinks results in for this stone!
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 212 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();
            let right = stone_str[half..].parse::<i64>().unwrap();

            count_stones_recursive(left, blinks - 1, memo) +
            count_stones_recursive(right, blinks - 1, memo)
        } else {
            count_stones_recursive(stone * 2024, blinks - 1, memo)
        }
    };

    memo.insert(key, result);
    result
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      This is where a major optimization gain is - if we've already seen this stone and blinks combo, we can immediately return the count that this number of blinks results in for this stone!
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 213 (author-speak-before) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();
            let right = stone_str[half..].parse::<i64>().unwrap();

            count_stones_recursive(left, blinks - 1, memo) +
            count_stones_recursive(right, blinks - 1, memo)
        } else {
            count_stones_recursive(stone * 2024, blinks - 1, memo)
        }
    };

    memo.insert(key, result);
    result
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Now let's use this optimized solution to solve Part 2 of the challenge...
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 213 (editor-enter) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();
            let right = stone_str[half..].parse::<i64>().unwrap();

            count_stones_recursive(left, blinks - 1, memo) +
            count_stones_recursive(right, blinks - 1, memo)
        } else {
            count_stones_recursive(stone * 2024, blinks - 1, memo)
        }
    };

    memo.insert(key, result);
    result
</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      This is where a major optimization gain is - if we've already seen this stone and blinks combo, we can immediately return the count that this number of blinks results in for this stone!
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 214 (editor-arrow-up) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();
            let right = stone_str[half..].parse::<i64>().unwrap();

            count_stones_recursive(left, blinks - 1, memo) +
            count_stones_recursive(right, blinks - 1, memo)
        } else {
            count_stones_recursive(stone * 2024, blinks - 1, memo)
        }
    };

    memo.insert(key, result);
    result
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Now let's use this optimized solution to solve Part 2 of the challenge...
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 214 (editor-type) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();
            let right = stone_str[half..].parse::<i64>().unwrap();

            count_stones_recursive(left, blinks - 1, memo) +
            count_stones_recursive(right, blinks - 1, memo)
        } else {
            count_stones_recursive(stone * 2024, blinks - 1, memo)
        }
    };

    memo.insert(key, result);
    result
}</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      This is where a major optimization gain is - if we've already seen this stone and blinks combo, we can immediately return the count that this number of blinks results in for this stone!
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 215 (author-speak-before) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();
            let right = stone_str[half..].parse::<i64>().unwrap();

            count_stones_recursive(left, blinks - 1, memo) +
            count_stones_recursive(right, blinks - 1, memo)
        } else {
            count_stones_recursive(stone * 2024, blinks - 1, memo)
        }
    };

    memo.insert(key, result);
    result
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We'll comment out part one here...
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 216 (editor-arrow-up) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();
            let right = stone_str[half..].parse::<i64>().unwrap();

            count_stones_recursive(left, blinks - 1, memo) +
            count_stones_recursive(right, blinks - 1, memo)
        } else {
            count_stones_recursive(stone * 2024, blinks - 1, memo)
        }
    };

    memo.insert(key, result);
    result
}</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Now let's use this optimized solution to solve Part 2 of the challenge...
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 216 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
 //   println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();
            let right = stone_str[half..].parse::<i64>().unwrap();

            count_stones_recursive(left, blinks - 1, memo) +
            count_stones_recursive(right, blinks - 1, memo)
        } else {
            count_stones_recursive(stone * 2024, blinks - 1, memo)
        }
    };

    memo.insert(key, result);
    result
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We'll comment out part one here...
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 217 (author-speak-before) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
    println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();
            let right = stone_str[half..].parse::<i64>().unwrap();

            count_stones_recursive(left, blinks - 1, memo) +
            count_stones_recursive(right, blinks - 1, memo)
        } else {
            count_stones_recursive(stone * 2024, blinks - 1, memo)
        }
    };

    memo.insert(key, result);
    result
}</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We'll comment out part one here...
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 217 (editor-command-right) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
 //   println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();
            let right = stone_str[half..].parse::<i64>().unwrap();

            count_stones_recursive(left, blinks - 1, memo) +
            count_stones_recursive(right, blinks - 1, memo)
        } else {
            count_stones_recursive(stone * 2024, blinks - 1, memo)
        }
    };

    memo.insert(key, result);
    result
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We'll comment out part one here...
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 218 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
 //   println!("Count of stones after 25 blinks: {}", stone_engravings.len());

    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();
            let right = stone_str[half..].parse::<i64>().unwrap();

            count_stones_recursive(left, blinks - 1, memo) +
            count_stones_recursive(right, blinks - 1, memo)
        } else {
            count_stones_recursive(stone * 2024, blinks - 1, memo)
        }
    };

    memo.insert(key, result);
    result
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We'll comment out part one here...
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 218 (editor-type) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
 //   println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();
            let right = stone_str[half..].parse::<i64>().unwrap();

            count_stones_recursive(left, blinks - 1, memo) +
            count_stones_recursive(right, blinks - 1, memo)
        } else {
            count_stones_recursive(stone * 2024, blinks - 1, memo)
        }
    };

    memo.insert(key, result);
    result
}</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We'll comment out part one here...
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 219 (editor-command-right) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
 //   println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();
            let right = stone_str[half..].parse::<i64>().unwrap();

            count_stones_recursive(left, blinks - 1, memo) +
            count_stones_recursive(right, blinks - 1, memo)
        } else {
            count_stones_recursive(stone * 2024, blinks - 1, memo)
        }
    };

    memo.insert(key, result);
    result
}</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We'll comment out part one here...
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 219 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
 //   println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    run_part_two();
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();
            let right = stone_str[half..].parse::<i64>().unwrap();

            count_stones_recursive(left, blinks - 1, memo) +
            count_stones_recursive(right, blinks - 1, memo)
        } else {
            count_stones_recursive(stone * 2024, blinks - 1, memo)
        }
    };

    memo.insert(key, result);
    result
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We'll comment out part one here...
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 220 (author-speak-before) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
 //   println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    run_part_two();
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();
            let right = stone_str[half..].parse::<i64>().unwrap();

            count_stones_recursive(left, blinks - 1, memo) +
            count_stones_recursive(right, blinks - 1, memo)
        } else {
            count_stones_recursive(stone * 2024, blinks - 1, memo)
        }
    };

    memo.insert(key, result);
    result
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      And call run part two.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 220 (editor-enter) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
 //   println!("Count of stones after 25 blinks: {}", stone_engravings.len());

    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();
            let right = stone_str[half..].parse::<i64>().unwrap();

            count_stones_recursive(left, blinks - 1, memo) +
            count_stones_recursive(right, blinks - 1, memo)
        } else {
            count_stones_recursive(stone * 2024, blinks - 1, memo)
        }
    };

    memo.insert(key, result);
    result
}</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We'll comment out part one here...
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 221 (editor-arrow-down) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
 //   println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    run_part_two();
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();
            let right = stone_str[half..].parse::<i64>().unwrap();

            count_stones_recursive(left, blinks - 1, memo) +
            count_stones_recursive(right, blinks - 1, memo)
        } else {
            count_stones_recursive(stone * 2024, blinks - 1, memo)
        }
    };

    memo.insert(key, result);
    result
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      And call run part two.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 221 (editor-type) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
 //   println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    run_part_two();
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();
            let right = stone_str[half..].parse::<i64>().unwrap();

            count_stones_recursive(left, blinks - 1, memo) +
            count_stones_recursive(right, blinks - 1, memo)
        } else {
            count_stones_recursive(stone * 2024, blinks - 1, memo)
        }
    };

    memo.insert(key, result);
    result
}</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      We'll comment out part one here...
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 222 (author-speak-before) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
 //   println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    run_part_two();
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();
            let right = stone_str[half..].parse::<i64>().unwrap();

            count_stones_recursive(left, blinks - 1, memo) +
            count_stones_recursive(right, blinks - 1, memo)
        } else {
            count_stones_recursive(stone * 2024, blinks - 1, memo)
        }
    };

    memo.insert(key, result);
    result
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      And run part two looks like:
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 223 (editor-arrow-down) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
 //   println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    run_part_two();
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();
            let right = stone_str[half..].parse::<i64>().unwrap();

            count_stones_recursive(left, blinks - 1, memo) +
            count_stones_recursive(right, blinks - 1, memo)
        } else {
            count_stones_recursive(stone * 2024, blinks - 1, memo)
        }
    };

    memo.insert(key, result);
    result
}</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      And call run part two.
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 223 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
 //   println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    run_part_two();
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();
            let right = stone_str[half..].parse::<i64>().unwrap();

            count_stones_recursive(left, blinks - 1, memo) +
            count_stones_recursive(right, blinks - 1, memo)
        } else {
            count_stones_recursive(stone * 2024, blinks - 1, memo)
        }
    };

    memo.insert(key, result);
    result
}

</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      And run part two looks like:
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 224 (author-speak-before) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
 //   println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    run_part_two();
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();
            let right = stone_str[half..].parse::<i64>().unwrap();

            count_stones_recursive(left, blinks - 1, memo) +
            count_stones_recursive(right, blinks - 1, memo)
        } else {
            count_stones_recursive(stone * 2024, blinks - 1, memo)
        }
    };

    memo.insert(key, result);
    result
}</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      And run part two looks like:
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 224 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
 //   println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    run_part_two();
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();
            let right = stone_str[half..].parse::<i64>().unwrap();

            count_stones_recursive(left, blinks - 1, memo) +
            count_stones_recursive(right, blinks - 1, memo)
        } else {
            count_stones_recursive(stone * 2024, blinks - 1, memo)
        }
    };

    memo.insert(key, result);
    result
}

pub fn run_part_two() -> std::io::Result<()> {</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      And run part two looks like:
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 225 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
 //   println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    run_part_two();
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();
            let right = stone_str[half..].parse::<i64>().unwrap();

            count_stones_recursive(left, blinks - 1, memo) +
            count_stones_recursive(right, blinks - 1, memo)
        } else {
            count_stones_recursive(stone * 2024, blinks - 1, memo)
        }
    };

    memo.insert(key, result);
    result
}

pub fn run_part_two() -> std::io::Result<()> {
</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      And run part two looks like:
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 226 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
 //   println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    run_part_two();
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();
            let right = stone_str[half..].parse::<i64>().unwrap();

            count_stones_recursive(left, blinks - 1, memo) +
            count_stones_recursive(right, blinks - 1, memo)
        } else {
            count_stones_recursive(stone * 2024, blinks - 1, memo)
        }
    };

    memo.insert(key, result);
    result
}

pub fn run_part_two() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      And run part two looks like:
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 227 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
 //   println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    run_part_two();
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();
            let right = stone_str[half..].parse::<i64>().unwrap();

            count_stones_recursive(left, blinks - 1, memo) +
            count_stones_recursive(right, blinks - 1, memo)
        } else {
            count_stones_recursive(stone * 2024, blinks - 1, memo)
        }
    };

    memo.insert(key, result);
    result
}

pub fn run_part_two() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      And run part two looks like:
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 228 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
 //   println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    run_part_two();
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();
            let right = stone_str[half..].parse::<i64>().unwrap();

            count_stones_recursive(left, blinks - 1, memo) +
            count_stones_recursive(right, blinks - 1, memo)
        } else {
            count_stones_recursive(stone * 2024, blinks - 1, memo)
        }
    };

    memo.insert(key, result);
    result
}

pub fn run_part_two() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stones: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      And run part two looks like:
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 229 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
 //   println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    run_part_two();
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();
            let right = stone_str[half..].parse::<i64>().unwrap();

            count_stones_recursive(left, blinks - 1, memo) +
            count_stones_recursive(right, blinks - 1, memo)
        } else {
            count_stones_recursive(stone * 2024, blinks - 1, memo)
        }
    };

    memo.insert(key, result);
    result
}

pub fn run_part_two() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stones: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();
</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      And run part two looks like:
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 230 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
 //   println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    run_part_two();
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();
            let right = stone_str[half..].parse::<i64>().unwrap();

            count_stones_recursive(left, blinks - 1, memo) +
            count_stones_recursive(right, blinks - 1, memo)
        } else {
            count_stones_recursive(stone * 2024, blinks - 1, memo)
        }
    };

    memo.insert(key, result);
    result
}

pub fn run_part_two() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stones: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();
    let blinks = 75;</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      And run part two looks like:
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 231 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
 //   println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    run_part_two();
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();
            let right = stone_str[half..].parse::<i64>().unwrap();

            count_stones_recursive(left, blinks - 1, memo) +
            count_stones_recursive(right, blinks - 1, memo)
        } else {
            count_stones_recursive(stone * 2024, blinks - 1, memo)
        }
    };

    memo.insert(key, result);
    result
}

pub fn run_part_two() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stones: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();
    let blinks = 75;

</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      And run part two looks like:
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 232 (author-speak-before) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
 //   println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    run_part_two();
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();
            let right = stone_str[half..].parse::<i64>().unwrap();

            count_stones_recursive(left, blinks - 1, memo) +
            count_stones_recursive(right, blinks - 1, memo)
        } else {
            count_stones_recursive(stone * 2024, blinks - 1, memo)
        }
    };

    memo.insert(key, result);
    result
}

pub fn run_part_two() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stones: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();
    let blinks = 75;

</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Here's where further elegance shines through. Instead of simulating each blink step by step, we're going to use our memoized recursive function to calculate the total stones efficiently. We can give our map function the desired number of blinks directly.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 232 (editor-type) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
 //   println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    run_part_two();
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();
            let right = stone_str[half..].parse::<i64>().unwrap();

            count_stones_recursive(left, blinks - 1, memo) +
            count_stones_recursive(right, blinks - 1, memo)
        } else {
            count_stones_recursive(stone * 2024, blinks - 1, memo)
        }
    };

    memo.insert(key, result);
    result
}

pub fn run_part_two() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stones: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();
    let blinks = 75;</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      And run part two looks like:
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 233 (editor-enter) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
 //   println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    run_part_two();
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();
            let right = stone_str[half..].parse::<i64>().unwrap();

            count_stones_recursive(left, blinks - 1, memo) +
            count_stones_recursive(right, blinks - 1, memo)
        } else {
            count_stones_recursive(stone * 2024, blinks - 1, memo)
        }
    };

    memo.insert(key, result);
    result
}

pub fn run_part_two() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stones: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();
    let blinks = 75;

</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      And run part two looks like:
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 233 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
 //   println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    run_part_two();
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();
            let right = stone_str[half..].parse::<i64>().unwrap();

            count_stones_recursive(left, blinks - 1, memo) +
            count_stones_recursive(right, blinks - 1, memo)
        } else {
            count_stones_recursive(stone * 2024, blinks - 1, memo)
        }
    };

    memo.insert(key, result);
    result
}

pub fn run_part_two() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stones: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();
    let blinks = 75;

    let mut memo = HashMap::new();</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Here's where further elegance shines through. Instead of simulating each blink step by step, we're going to use our memoized recursive function to calculate the total stones efficiently. We can give our map function the desired number of blinks directly.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 234 (author-speak-before) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
 //   println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    run_part_two();
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();
            let right = stone_str[half..].parse::<i64>().unwrap();

            count_stones_recursive(left, blinks - 1, memo) +
            count_stones_recursive(right, blinks - 1, memo)
        } else {
            count_stones_recursive(stone * 2024, blinks - 1, memo)
        }
    };

    memo.insert(key, result);
    result
}

pub fn run_part_two() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stones: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();
    let blinks = 75;

</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Here's where further elegance shines through. Instead of simulating each blink step by step, we're going to use our memoized recursive function to calculate the total stones efficiently. We can give our map function the desired number of blinks directly.
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 234 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
 //   println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    run_part_two();
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();
            let right = stone_str[half..].parse::<i64>().unwrap();

            count_stones_recursive(left, blinks - 1, memo) +
            count_stones_recursive(right, blinks - 1, memo)
        } else {
            count_stones_recursive(stone * 2024, blinks - 1, memo)
        }
    };

    memo.insert(key, result);
    result
}

pub fn run_part_two() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stones: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();
    let blinks = 75;

    let mut memo = HashMap::new();

</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Here's where further elegance shines through. Instead of simulating each blink step by step, we're going to use our memoized recursive function to calculate the total stones efficiently. We can give our map function the desired number of blinks directly.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 235 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
 //   println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    run_part_two();
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();
            let right = stone_str[half..].parse::<i64>().unwrap();

            count_stones_recursive(left, blinks - 1, memo) +
            count_stones_recursive(right, blinks - 1, memo)
        } else {
            count_stones_recursive(stone * 2024, blinks - 1, memo)
        }
    };

    memo.insert(key, result);
    result
}

pub fn run_part_two() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stones: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();
    let blinks = 75;

    let mut memo = HashMap::new();

    let total: usize = initial_stones.iter()</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Here's where further elegance shines through. Instead of simulating each blink step by step, we're going to use our memoized recursive function to calculate the total stones efficiently. We can give our map function the desired number of blinks directly.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 236 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
 //   println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    run_part_two();
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();
            let right = stone_str[half..].parse::<i64>().unwrap();

            count_stones_recursive(left, blinks - 1, memo) +
            count_stones_recursive(right, blinks - 1, memo)
        } else {
            count_stones_recursive(stone * 2024, blinks - 1, memo)
        }
    };

    memo.insert(key, result);
    result
}

pub fn run_part_two() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stones: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();
    let blinks = 75;

    let mut memo = HashMap::new();

    let total: usize = initial_stones.iter()
</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Here's where further elegance shines through. Instead of simulating each blink step by step, we're going to use our memoized recursive function to calculate the total stones efficiently. We can give our map function the desired number of blinks directly.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 237 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
 //   println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    run_part_two();
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();
            let right = stone_str[half..].parse::<i64>().unwrap();

            count_stones_recursive(left, blinks - 1, memo) +
            count_stones_recursive(right, blinks - 1, memo)
        } else {
            count_stones_recursive(stone * 2024, blinks - 1, memo)
        }
    };

    memo.insert(key, result);
    result
}

pub fn run_part_two() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stones: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();
    let blinks = 75;

    let mut memo = HashMap::new();

    let total: usize = initial_stones.iter()
        .map(|&stone| {</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Here's where further elegance shines through. Instead of simulating each blink step by step, we're going to use our memoized recursive function to calculate the total stones efficiently. We can give our map function the desired number of blinks directly.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 238 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
 //   println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    run_part_two();
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();
            let right = stone_str[half..].parse::<i64>().unwrap();

            count_stones_recursive(left, blinks - 1, memo) +
            count_stones_recursive(right, blinks - 1, memo)
        } else {
            count_stones_recursive(stone * 2024, blinks - 1, memo)
        }
    };

    memo.insert(key, result);
    result
}

pub fn run_part_two() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stones: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();
    let blinks = 75;

    let mut memo = HashMap::new();

    let total: usize = initial_stones.iter()
        .map(|&stone| {
</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Here's where further elegance shines through. Instead of simulating each blink step by step, we're going to use our memoized recursive function to calculate the total stones efficiently. We can give our map function the desired number of blinks directly.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 239 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
 //   println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    run_part_two();
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();
            let right = stone_str[half..].parse::<i64>().unwrap();

            count_stones_recursive(left, blinks - 1, memo) +
            count_stones_recursive(right, blinks - 1, memo)
        } else {
            count_stones_recursive(stone * 2024, blinks - 1, memo)
        }
    };

    memo.insert(key, result);
    result
}

pub fn run_part_two() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stones: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();
    let blinks = 75;

    let mut memo = HashMap::new();

    let total: usize = initial_stones.iter()
        .map(|&stone| {
            count_stones_recursive(stone, blinks, &mut memo)</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Here's where further elegance shines through. Instead of simulating each blink step by step, we're going to use our memoized recursive function to calculate the total stones efficiently. We can give our map function the desired number of blinks directly.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 240 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
 //   println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    run_part_two();
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();
            let right = stone_str[half..].parse::<i64>().unwrap();

            count_stones_recursive(left, blinks - 1, memo) +
            count_stones_recursive(right, blinks - 1, memo)
        } else {
            count_stones_recursive(stone * 2024, blinks - 1, memo)
        }
    };

    memo.insert(key, result);
    result
}

pub fn run_part_two() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stones: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();
    let blinks = 75;

    let mut memo = HashMap::new();

    let total: usize = initial_stones.iter()
        .map(|&stone| {
            count_stones_recursive(stone, blinks, &mut memo)
</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Here's where further elegance shines through. Instead of simulating each blink step by step, we're going to use our memoized recursive function to calculate the total stones efficiently. We can give our map function the desired number of blinks directly.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 241 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
 //   println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    run_part_two();
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();
            let right = stone_str[half..].parse::<i64>().unwrap();

            count_stones_recursive(left, blinks - 1, memo) +
            count_stones_recursive(right, blinks - 1, memo)
        } else {
            count_stones_recursive(stone * 2024, blinks - 1, memo)
        }
    };

    memo.insert(key, result);
    result
}

pub fn run_part_two() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stones: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();
    let blinks = 75;

    let mut memo = HashMap::new();

    let total: usize = initial_stones.iter()
        .map(|&stone| {
            count_stones_recursive(stone, blinks, &mut memo)
        })</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Here's where further elegance shines through. Instead of simulating each blink step by step, we're going to use our memoized recursive function to calculate the total stones efficiently. We can give our map function the desired number of blinks directly.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 242 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
 //   println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    run_part_two();
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();
            let right = stone_str[half..].parse::<i64>().unwrap();

            count_stones_recursive(left, blinks - 1, memo) +
            count_stones_recursive(right, blinks - 1, memo)
        } else {
            count_stones_recursive(stone * 2024, blinks - 1, memo)
        }
    };

    memo.insert(key, result);
    result
}

pub fn run_part_two() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stones: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();
    let blinks = 75;

    let mut memo = HashMap::new();

    let total: usize = initial_stones.iter()
        .map(|&stone| {
            count_stones_recursive(stone, blinks, &mut memo)
        })
</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Here's where further elegance shines through. Instead of simulating each blink step by step, we're going to use our memoized recursive function to calculate the total stones efficiently. We can give our map function the desired number of blinks directly.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 243 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
 //   println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    run_part_two();
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();
            let right = stone_str[half..].parse::<i64>().unwrap();

            count_stones_recursive(left, blinks - 1, memo) +
            count_stones_recursive(right, blinks - 1, memo)
        } else {
            count_stones_recursive(stone * 2024, blinks - 1, memo)
        }
    };

    memo.insert(key, result);
    result
}

pub fn run_part_two() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stones: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();
    let blinks = 75;

    let mut memo = HashMap::new();

    let total: usize = initial_stones.iter()
        .map(|&stone| {
            count_stones_recursive(stone, blinks, &mut memo)
        })
        .sum();</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Here's where further elegance shines through. Instead of simulating each blink step by step, we're going to use our memoized recursive function to calculate the total stones efficiently. We can give our map function the desired number of blinks directly.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 244 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
 //   println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    run_part_two();
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();
            let right = stone_str[half..].parse::<i64>().unwrap();

            count_stones_recursive(left, blinks - 1, memo) +
            count_stones_recursive(right, blinks - 1, memo)
        } else {
            count_stones_recursive(stone * 2024, blinks - 1, memo)
        }
    };

    memo.insert(key, result);
    result
}

pub fn run_part_two() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stones: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();
    let blinks = 75;

    let mut memo = HashMap::new();

    let total: usize = initial_stones.iter()
        .map(|&stone| {
            count_stones_recursive(stone, blinks, &mut memo)
        })
        .sum();

</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Here's where further elegance shines through. Instead of simulating each blink step by step, we're going to use our memoized recursive function to calculate the total stones efficiently. We can give our map function the desired number of blinks directly.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 245 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
 //   println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    run_part_two();
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();
            let right = stone_str[half..].parse::<i64>().unwrap();

            count_stones_recursive(left, blinks - 1, memo) +
            count_stones_recursive(right, blinks - 1, memo)
        } else {
            count_stones_recursive(stone * 2024, blinks - 1, memo)
        }
    };

    memo.insert(key, result);
    result
}

pub fn run_part_two() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stones: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();
    let blinks = 75;

    let mut memo = HashMap::new();

    let total: usize = initial_stones.iter()
        .map(|&stone| {
            count_stones_recursive(stone, blinks, &mut memo)
        })
        .sum();

    println!("Total stones after {} blinks: {}", blinks, total);</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Here's where further elegance shines through. Instead of simulating each blink step by step, we're going to use our memoized recursive function to calculate the total stones efficiently. We can give our map function the desired number of blinks directly.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 246 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
 //   println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    run_part_two();
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();
            let right = stone_str[half..].parse::<i64>().unwrap();

            count_stones_recursive(left, blinks - 1, memo) +
            count_stones_recursive(right, blinks - 1, memo)
        } else {
            count_stones_recursive(stone * 2024, blinks - 1, memo)
        }
    };

    memo.insert(key, result);
    result
}

pub fn run_part_two() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stones: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();
    let blinks = 75;

    let mut memo = HashMap::new();

    let total: usize = initial_stones.iter()
        .map(|&stone| {
            count_stones_recursive(stone, blinks, &mut memo)
        })
        .sum();

    println!("Total stones after {} blinks: {}", blinks, total);

</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Here's where further elegance shines through. Instead of simulating each blink step by step, we're going to use our memoized recursive function to calculate the total stones efficiently. We can give our map function the desired number of blinks directly.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 247 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
 //   println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    run_part_two();
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();
            let right = stone_str[half..].parse::<i64>().unwrap();

            count_stones_recursive(left, blinks - 1, memo) +
            count_stones_recursive(right, blinks - 1, memo)
        } else {
            count_stones_recursive(stone * 2024, blinks - 1, memo)
        }
    };

    memo.insert(key, result);
    result
}

pub fn run_part_two() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stones: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();
    let blinks = 75;

    let mut memo = HashMap::new();

    let total: usize = initial_stones.iter()
        .map(|&stone| {
            count_stones_recursive(stone, blinks, &mut memo)
        })
        .sum();

    println!("Total stones after {} blinks: {}", blinks, total);

    Ok(())</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Here's where further elegance shines through. Instead of simulating each blink step by step, we're going to use our memoized recursive function to calculate the total stones efficiently. We can give our map function the desired number of blinks directly.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 248 (editor-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
 //   println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    run_part_two();
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();
            let right = stone_str[half..].parse::<i64>().unwrap();

            count_stones_recursive(left, blinks - 1, memo) +
            count_stones_recursive(right, blinks - 1, memo)
        } else {
            count_stones_recursive(stone * 2024, blinks - 1, memo)
        }
    };

    memo.insert(key, result);
    result
}

pub fn run_part_two() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stones: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();
    let blinks = 75;

    let mut memo = HashMap::new();

    let total: usize = initial_stones.iter()
        .map(|&stone| {
            count_stones_recursive(stone, blinks, &mut memo)
        })
        .sum();

    println!("Total stones after {} blinks: {}", blinks, total);

    Ok(())
</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Here's where further elegance shines through. Instead of simulating each blink step by step, we're going to use our memoized recursive function to calculate the total stones efficiently. We can give our map function the desired number of blinks directly.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 249 (editor-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
 //   println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    run_part_two();
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();
            let right = stone_str[half..].parse::<i64>().unwrap();

            count_stones_recursive(left, blinks - 1, memo) +
            count_stones_recursive(right, blinks - 1, memo)
        } else {
            count_stones_recursive(stone * 2024, blinks - 1, memo)
        }
    };

    memo.insert(key, result);
    result
}

pub fn run_part_two() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stones: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();
    let blinks = 75;

    let mut memo = HashMap::new();

    let total: usize = initial_stones.iter()
        .map(|&stone| {
            count_stones_recursive(stone, blinks, &mut memo)
        })
        .sum();

    println!("Total stones after {} blinks: {}", blinks, total);

    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Here's where further elegance shines through. Instead of simulating each blink step by step, we're going to use our memoized recursive function to calculate the total stones efficiently. We can give our map function the desired number of blinks directly.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 250 (author-speak-before) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
 //   println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    run_part_two();
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();
            let right = stone_str[half..].parse::<i64>().unwrap();

            count_stones_recursive(left, blinks - 1, memo) +
            count_stones_recursive(right, blinks - 1, memo)
        } else {
            count_stones_recursive(stone * 2024, blinks - 1, memo)
        }
    };

    memo.insert(key, result);
    result
}

pub fn run_part_two() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stones: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();
    let blinks = 75;

    let mut memo = HashMap::new();

    let total: usize = initial_stones.iter()
        .map(|&stone| {
            count_stones_recursive(stone, blinks, &mut memo)
        })
        .sum();

    println!("Total stones after {} blinks: {}", blinks, total);

    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Now, let's run this optimized solution and see how it performs...
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 250 (editor-enter) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
 //   println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    run_part_two();
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();
            let right = stone_str[half..].parse::<i64>().unwrap();

            count_stones_recursive(left, blinks - 1, memo) +
            count_stones_recursive(right, blinks - 1, memo)
        } else {
            count_stones_recursive(stone * 2024, blinks - 1, memo)
        }
    };

    memo.insert(key, result);
    result
}

pub fn run_part_two() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stones: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();
    let blinks = 75;

    let mut memo = HashMap::new();

    let total: usize = initial_stones.iter()
        .map(|&stone| {
            count_stones_recursive(stone, blinks, &mut memo)
        })
        .sum();

    println!("Total stones after {} blinks: {}", blinks, total);

    Ok(())
</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Here's where further elegance shines through. Instead of simulating each blink step by step, we're going to use our memoized recursive function to calculate the total stones efficiently. We can give our map function the desired number of blinks directly.
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 251 (author-speak-before) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
 //   println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    run_part_two();
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();
            let right = stone_str[half..].parse::<i64>().unwrap();

            count_stones_recursive(left, blinks - 1, memo) +
            count_stones_recursive(right, blinks - 1, memo)
        } else {
            count_stones_recursive(stone * 2024, blinks - 1, memo)
        }
    };

    memo.insert(key, result);
    result
}

pub fn run_part_two() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stones: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();
    let blinks = 75;

    let mut memo = HashMap::new();

    let total: usize = initial_stones.iter()
        .map(|&stone| {
            count_stones_recursive(stone, blinks, &mut memo)
        })
        .sum();

    println!("Total stones after {} blinks: {}", blinks, total);

    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      And let's run this with cargo run:
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 251 (editor-type) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
 //   println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    run_part_two();
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();
            let right = stone_str[half..].parse::<i64>().unwrap();

            count_stones_recursive(left, blinks - 1, memo) +
            count_stones_recursive(right, blinks - 1, memo)
        } else {
            count_stones_recursive(stone * 2024, blinks - 1, memo)
        }
    };

    memo.insert(key, result);
    result
}

pub fn run_part_two() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stones: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();
    let blinks = 75;

    let mut memo = HashMap::new();

    let total: usize = initial_stones.iter()
        .map(|&stone| {
            count_stones_recursive(stone, blinks, &mut memo)
        })
        .sum();

    println!("Total stones after {} blinks: {}", blinks, total);

    Ok(())
}</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Here's where further elegance shines through. Instead of simulating each blink step by step, we're going to use our memoized recursive function to calculate the total stones efficiently. We can give our map function the desired number of blinks directly.
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 252 (author-speak-before) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
 //   println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    run_part_two();
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();
            let right = stone_str[half..].parse::<i64>().unwrap();

            count_stones_recursive(left, blinks - 1, memo) +
            count_stones_recursive(right, blinks - 1, memo)
        } else {
            count_stones_recursive(stone * 2024, blinks - 1, memo)
        }
    };

    memo.insert(key, result);
    result
}

pub fn run_part_two() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stones: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();
    let blinks = 75;

    let mut memo = HashMap::new();

    let total: usize = initial_stones.iter()
        .map(|&stone| {
            count_stones_recursive(stone, blinks, &mut memo)
        })
        .sum();

    println!("Total stones after {} blinks: {}", blinks, total);

    Ok(())
}</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Now, let's run this optimized solution and see how it performs...
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 252 (mouse-click-terminal) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
 //   println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    run_part_two();
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();
            let right = stone_str[half..].parse::<i64>().unwrap();

            count_stones_recursive(left, blinks - 1, memo) +
            count_stones_recursive(right, blinks - 1, memo)
        } else {
            count_stones_recursive(stone * 2024, blinks - 1, memo)
        }
    };

    memo.insert(key, result);
    result
}

pub fn run_part_two() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stones: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();
    let blinks = 75;

    let mut memo = HashMap::new();

    let total: usize = initial_stones.iter()
        .map(|&stone| {
            count_stones_recursive(stone, blinks, &mut memo)
        })
        .sum();

    println!("Total stones after {} blinks: {}", blinks, total);

    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      And let's run this with cargo run:
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 253 (author-speak-before) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
 //   println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    run_part_two();
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();
            let right = stone_str[half..].parse::<i64>().unwrap();

            count_stones_recursive(left, blinks - 1, memo) +
            count_stones_recursive(right, blinks - 1, memo)
        } else {
            count_stones_recursive(stone * 2024, blinks - 1, memo)
        }
    };

    memo.insert(key, result);
    result
}

pub fn run_part_two() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stones: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();
    let blinks = 75;

    let mut memo = HashMap::new();

    let total: usize = initial_stones.iter()
        .map(|&stone| {
            count_stones_recursive(stone, blinks, &mut memo)
        })
        .sum();

    println!("Total stones after {} blinks: {}", blinks, total);

    Ok(())
}</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      And let's run this with cargo run:
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 253 (terminal-type) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
 //   println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    run_part_two();
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();
            let right = stone_str[half..].parse::<i64>().unwrap();

            count_stones_recursive(left, blinks - 1, memo) +
            count_stones_recursive(right, blinks - 1, memo)
        } else {
            count_stones_recursive(stone * 2024, blinks - 1, memo)
        }
    };

    memo.insert(key, result);
    result
}

pub fn run_part_two() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stones: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();
    let blinks = 75;

    let mut memo = HashMap::new();

    let total: usize = initial_stones.iter()
        .map(|&stone| {
            count_stones_recursive(stone, blinks, &mut memo)
        })
        .sum();

    println!("Total stones after {} blinks: {}", blinks, total);

    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      And let's run this with cargo run:
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;">cargo run</pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 254 (mouse-click-terminal) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
 //   println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    run_part_two();
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();
            let right = stone_str[half..].parse::<i64>().unwrap();

            count_stones_recursive(left, blinks - 1, memo) +
            count_stones_recursive(right, blinks - 1, memo)
        } else {
            count_stones_recursive(stone * 2024, blinks - 1, memo)
        }
    };

    memo.insert(key, result);
    result
}

pub fn run_part_two() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stones: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();
    let blinks = 75;

    let mut memo = HashMap::new();

    let total: usize = initial_stones.iter()
        .map(|&stone| {
            count_stones_recursive(stone, blinks, &mut memo)
        })
        .sum();

    println!("Total stones after {} blinks: {}", blinks, total);

    Ok(())
}</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      And let's run this with cargo run:
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 254 (terminal-enter) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
 //   println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    run_part_two();
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();
            let right = stone_str[half..].parse::<i64>().unwrap();

            count_stones_recursive(left, blinks - 1, memo) +
            count_stones_recursive(right, blinks - 1, memo)
        } else {
            count_stones_recursive(stone * 2024, blinks - 1, memo)
        }
    };

    memo.insert(key, result);
    result
}

pub fn run_part_two() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stones: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();
    let blinks = 75;

    let mut memo = HashMap::new();

    let total: usize = initial_stones.iter()
        .map(|&stone| {
            count_stones_recursive(stone, blinks, &mut memo)
        })
        .sum();

    println!("Total stones after {} blinks: {}", blinks, total);

    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      And let's run this with cargo run:
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 255 (author-speak-before) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
 //   println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    run_part_two();
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();
            let right = stone_str[half..].parse::<i64>().unwrap();

            count_stones_recursive(left, blinks - 1, memo) +
            count_stones_recursive(right, blinks - 1, memo)
        } else {
            count_stones_recursive(stone * 2024, blinks - 1, memo)
        }
    };

    memo.insert(key, result);
    result
}

pub fn run_part_two() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stones: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();
    let blinks = 75;

    let mut memo = HashMap::new();

    let total: usize = initial_stones.iter()
        .map(|&stone| {
            count_stones_recursive(stone, blinks, &mut memo)
        })
        .sum();

    println!("Total stones after {} blinks: {}", blinks, total);

    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Even with 75 blinks, our memoized solution calculates the result almost instantly! The answer, or rather, the final count of stones, is over 218 trillion! Something that couldn't be done quickly on even the craziest of hardware if done via brute force and storing all the stones in an array like our naive approach in part 1. 
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 255 (terminal-type) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
 //   println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    run_part_two();
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();
            let right = stone_str[half..].parse::<i64>().unwrap();

            count_stones_recursive(left, blinks - 1, memo) +
            count_stones_recursive(right, blinks - 1, memo)
        } else {
            count_stones_recursive(stone * 2024, blinks - 1, memo)
        }
    };

    memo.insert(key, result);
    result
}

pub fn run_part_two() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stones: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();
    let blinks = 75;

    let mut memo = HashMap::new();

    let total: usize = initial_stones.iter()
        .map(|&stone| {
            count_stones_recursive(stone, blinks, &mut memo)
        })
        .sum();

    println!("Total stones after {} blinks: {}", blinks, total);

    Ok(())
}</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      And let's run this with cargo run:
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript">cargo run</code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 256 (author-speak-before) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
 //   println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    run_part_two();
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();
            let right = stone_str[half..].parse::<i64>().unwrap();

            count_stones_recursive(left, blinks - 1, memo) +
            count_stones_recursive(right, blinks - 1, memo)
        } else {
            count_stones_recursive(stone * 2024, blinks - 1, memo)
        }
    };

    memo.insert(key, result);
    result
}

pub fn run_part_two() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stones: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();
    let blinks = 75;

    let mut memo = HashMap::new();

    let total: usize = initial_stones.iter()
        .map(|&stone| {
            count_stones_recursive(stone, blinks, &mut memo)
        })
        .sum();

    println!("Total stones after {} blinks: {}", blinks, total);

    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      This puzzle is a perfect example of how some smart algorithmic choices can solve problems that would be completely intractable with a naive approach.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 256 (terminal-enter) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
 //   println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    run_part_two();
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();
            let right = stone_str[half..].parse::<i64>().unwrap();

            count_stones_recursive(left, blinks - 1, memo) +
            count_stones_recursive(right, blinks - 1, memo)
        } else {
            count_stones_recursive(stone * 2024, blinks - 1, memo)
        }
    };

    memo.insert(key, result);
    result
}

pub fn run_part_two() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stones: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();
    let blinks = 75;

    let mut memo = HashMap::new();

    let total: usize = initial_stones.iter()
        .map(|&stone| {
            count_stones_recursive(stone, blinks, &mut memo)
        })
        .sum();

    println!("Total stones after {} blinks: {}", blinks, total);

    Ok(())
}</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      And let's run this with cargo run:
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 257 (author-speak-before) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
 //   println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    run_part_two();
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();
            let right = stone_str[half..].parse::<i64>().unwrap();

            count_stones_recursive(left, blinks - 1, memo) +
            count_stones_recursive(right, blinks - 1, memo)
        } else {
            count_stones_recursive(stone * 2024, blinks - 1, memo)
        }
    };

    memo.insert(key, result);
    result
}

pub fn run_part_two() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stones: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();
    let blinks = 75;

    let mut memo = HashMap::new();

    let total: usize = initial_stones.iter()
        .map(|&stone| {
            count_stones_recursive(stone, blinks, &mut memo)
        })
        .sum();

    println!("Total stones after {} blinks: {}", blinks, total);

    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Let's quickly review why this solution is so much more efficient...
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 258 (author-speak-before) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
 //   println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    run_part_two();
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();
            let right = stone_str[half..].parse::<i64>().unwrap();

            count_stones_recursive(left, blinks - 1, memo) +
            count_stones_recursive(right, blinks - 1, memo)
        } else {
            count_stones_recursive(stone * 2024, blinks - 1, memo)
        }
    };

    memo.insert(key, result);
    result
}

pub fn run_part_two() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stones: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();
    let blinks = 75;

    let mut memo = HashMap::new();

    let total: usize = initial_stones.iter()
        .map(|&stone| {
            count_stones_recursive(stone, blinks, &mut memo)
        })
        .sum();

    println!("Total stones after {} blinks: {}", blinks, total);

    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      Again, the naive solution would need to store and process an exponentially growing number of stones. With 75 blinks, we'd need to handle over 218 trillion stones in memory! You'd need some serious hardware to do that!
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 259 (author-speak-before) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
 //   println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    run_part_two();
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();
            let right = stone_str[half..].parse::<i64>().unwrap();

            count_stones_recursive(left, blinks - 1, memo) +
            count_stones_recursive(right, blinks - 1, memo)
        } else {
            count_stones_recursive(stone * 2024, blinks - 1, memo)
        }
    };

    memo.insert(key, result);
    result
}

pub fn run_part_two() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stones: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();
    let blinks = 75;

    let mut memo = HashMap::new();

    let total: usize = initial_stones.iter()
        .map(|&stone| {
            count_stones_recursive(stone, blinks, &mut memo)
        })
        .sum();

    println!("Total stones after {} blinks: {}", blinks, total);

    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      But our memoized solution just needs to store the count for each unique combination of stone value and remaining blinks. This dramatically reduces both memory usage and computation time.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 260 (author-speak-before) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
 //   println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    run_part_two();
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();
            let right = stone_str[half..].parse::<i64>().unwrap();

            count_stones_recursive(left, blinks - 1, memo) +
            count_stones_recursive(right, blinks - 1, memo)
        } else {
            count_stones_recursive(stone * 2024, blinks - 1, memo)
        }
    };

    memo.insert(key, result);
    result
}

pub fn run_part_two() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stones: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();
    let blinks = 75;

    let mut memo = HashMap::new();

    let total: usize = initial_stones.iter()
        .map(|&stone| {
            count_stones_recursive(stone, blinks, &mut memo)
        })
        .sum();

    println!("Total stones after {} blinks: {}", blinks, total);

    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      This optimization technique is particularly powerful because it takes advantage of the problem's structure - the fact that any given stone will always produce the same result after a certain number of blinks.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 261 (author-speak-before) 1`] = `
"
  <!DOCTYPE html>
  <html>
    <head>
      <meta charset="UTF-8">
      <title>VirtualIDE Snapshot</title>
    </head>
    <body style="margin:0; padding:0; font-family: monospace; position: relative;">
      <div style="display: flex; flex-direction: column; height: 100vh;">
        <!-- Main IDE Area -->
        <div style="flex: 1; display: flex;">
          <!-- Left: File Explorer (no label) -->
          <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
            <ul style='list-style: none; padding-left: 10px; margin: 0;'></ul>
          </div>
          <!-- Right: Editor -->
          <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
            <!-- Editor Tabs -->
            <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
              
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        // First, let's implement a naive solution for Part 1 <span style="color: red;">x</span>
      </div>
            </div>
            <!-- Editor Content -->
            <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
              <pre style="margin:0;">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
 //   println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    run_part_two();
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();
            let right = stone_str[half..].parse::<i64>().unwrap();

            count_stones_recursive(left, blinks - 1, memo) +
            count_stones_recursive(right, blinks - 1, memo)
        } else {
            count_stones_recursive(stone * 2024, blinks - 1, memo)
        }
    };

    memo.insert(key, result);
    result
}

pub fn run_part_two() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stones: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();
    let blinks = 75;

    let mut memo = HashMap::new();

    let total: usize = initial_stones.iter()
        .map(|&stone| {
            count_stones_recursive(stone, blinks, &mut memo)
        })
        .sum();

    println!("Total stones after {} blinks: {}", blinks, total);

    Ok(())
}</pre>
              <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      And that wraps up our exploration this elegant solution in Rust! Thanks for watching - I hope this helped demonstrate the power of careful algorithmic choices and how you can implement them in Rust.
    </div>
            </div>
          </div>
        </div>
        <!-- Bottom: Terminal -->
        <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
          <div style="font-weight: bold;">codevideo &gt; </div>
          <pre style="margin:0;"></pre>
        </div>
      </div>
      <!-- Mouse Pointer SVG -->
      
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
    </body>
  </html>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 262 (author-speak-before) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
 //   println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    run_part_two();
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();
            let right = stone_str[half..].parse::<i64>().unwrap();

            count_stones_recursive(left, blinks - 1, memo) +
            count_stones_recursive(right, blinks - 1, memo)
        } else {
            count_stones_recursive(stone * 2024, blinks - 1, memo)
        }
    };

    memo.insert(key, result);
    result
}

pub fn run_part_two() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stones: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();
    let blinks = 75;

    let mut memo = HashMap::new();

    let total: usize = initial_stones.iter()
        .map(|&stone| {
            count_stones_recursive(stone, blinks, &mut memo)
        })
        .sum();

    println!("Total stones after {} blinks: {}", blinks, total);

    Ok(())
}</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      This optimization technique is particularly powerful because it takes advantage of the problem's structure - the fact that any given stone will always produce the same result after a certain number of blinks.
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should capture snapshots after each action and write raw HTML files: Snapshot after action 263 (author-speak-before) 1`] = `
"
  <div style="display: flex; flex-direction: column; height: 100vh; position: relative;">
    <!-- Main IDE Area -->
    <div style="flex: 1; display: flex;">
      <!-- Left: File Explorer -->
      <div style="width: 200px; border: 1px solid black; padding: 5px; overflow: auto;">
        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style="margin: 2px 0;">main.rs</li></ul>
      </div>
      <!-- Right: Editor -->
      <div style="flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;">
        <!-- Editor Tabs -->
        <div style="height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;">
          
      <div style="
          padding: 2px 5px;
          border: 1px solid black;
          margin-right: 5px;
          background: #ddd;
          display: inline-block;">
        main.rs <span style="color: red;">x</span>
      </div>
        </div>
        <!-- Editor Content -->
        <div style="flex: 1; padding: 5px; overflow: auto; position: relative;">
          <pre style="margin:0;"><code class="language-javascript">use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead, BufReader};
use std::path::Path;

type MemoKey = (i64, usize);  // (stone_value, blinks_remaining)
type MemoMap = HashMap<MemoKey, usize>;

fn read_lines_as_int_arrays<P>(filename: P, sep: &str) -> io::Result<Vec<Vec<i32>>>
where
    P: AsRef<Path>,
{
    let file = File::open(filename)?;
    let reader = BufReader::new(file);
    let lines: Vec<Result<String, io::Error>> = reader.lines().collect();
    let mut int_arrays: Vec<Vec<i32>> = Vec::new();
    // split each line by the passed in sep and parse each element as an integer
    for line in lines {
        let line: String = line?;
        let int_array: Vec<i32> = line.split(sep).map(|x| x.parse::<i32>().unwrap()).collect();
        int_arrays.push(int_array);
    }
    Ok(int_arrays)
}

fn main() {
    run_part_one();
}




// First, let's implement a naive solution for Part 1
fn execute_blink(stone_engravings: Vec<i64>) -> Vec<i64> {
    let mut new_stones = Vec::new();

    for stone in stone_engravings {
        if stone == 0 {
            // Rule 1: stone = 0 -> replaced by stone marked 1
            new_stones.push(1);
        } else {
            let stone_str = stone.to_string();
            let stone_len = stone_str.len();

            if stone_len % 2 == 0 {
                // Rule 2: split into two stones
                let half = stone_len / 2;
                let left_stone = stone_str[0..half].parse::<i64>().unwrap();
                let right_stone = stone_str[half..].parse::<i64>().unwrap();

                new_stones.push(left_stone);
                new_stones.push(right_stone);
            } else {
                // Rule 3: multiply by 2024
                new_stones.push(stone * 2024);
            }
        }
    }

    new_stones
}

pub fn run_part_one() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stone_engravings: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();

    let mut stone_engravings = initial_stone_engravings.clone();
    for _ in 0..25 {
        stone_engravings = execute_blink(stone_engravings);
    }
 //   println!("Count of stones after 25 blinks: {}", stone_engravings.len());
    run_part_two();
    Ok(())
}
fn count_stones_recursive(stone: i64, blinks: usize, memo: &mut MemoMap) -> usize {
    if blinks == 0 { return 1; }

    let key = (stone, blinks);
    if let Some(&count) = memo.get(&key) { return count; }

    let result = if stone == 0 {
        count_stones_recursive(1, blinks - 1, memo)
    } else {
        let digit_count = stone.to_string().len();
        if digit_count % 2 == 0 {
            let stone_str = stone.to_string();
            let half = digit_count / 2;
            let left = stone_str[..half].parse::<i64>().unwrap();
            let right = stone_str[half..].parse::<i64>().unwrap();

            count_stones_recursive(left, blinks - 1, memo) +
            count_stones_recursive(right, blinks - 1, memo)
        } else {
            count_stones_recursive(stone * 2024, blinks - 1, memo)
        }
    };

    memo.insert(key, result);
    result
}

pub fn run_part_two() -> std::io::Result<()> {
    let input = read_lines_as_int_arrays("src/day_11/input.txt", "")?;

    let initial_stones: Vec<i64> = input[0].iter().map(|&x| x as i64).collect();
    let blinks = 75;

    let mut memo = HashMap::new();

    let total: usize = initial_stones.iter()
        .map(|&stone| {
            count_stones_recursive(stone, blinks, &mut memo)
        })
        .sum();

    println!("Total stones after {} blinks: {}", blinks, total);

    Ok(())
}</code></pre>
          <div style="
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 5px;
      font-size: 14px;
      text-align: center;
    ">
      And that wraps up our exploration this elegant solution in Rust! Thanks for watching - I hope this helped demonstrate the power of careful algorithmic choices and how you can implement them in Rust.
    </div>
        </div>
      </div>
    </div>
    <!-- Bottom: Terminal -->
    <div style="height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;">
      <div style="font-weight: bold;">codevideo &gt;</div>
      <pre style="margin:0;"><code class="language-javascript"></code></pre>
    </div>
    <!-- Mouse Pointer SVG -->
    
  <svg width="24" height="24" viewBox="0 0 24 24" style="position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;">
    <path d="M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z" fill="black" stroke="white" stroke-width="1.5" stroke-linejoin="round"></path>
  </svg>
  
  </div>
  "
`;

exports[`VirtualIDE Snapshot with IDE Layout should generate separated snapshots.js and viewer.html files: Generated snapshots module 1`] = `
"// Generated snapshots module
export const snapshots = [
  {
    "html": \`\\n  <div style=\\\`display: flex; flex-direction: column; height: 100vh; position: relative;\\">\\n    <!-- Main IDE Area -->\\n    <div style=\\"flex: 1; display: flex;\\">\\n      <!-- Left: File Explorer -->\\n      <div style=\\"width: 200px; border: 1px solid black; padding: 5px; overflow: auto;\\">\\n        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style=\\"margin: 2px 0;\\"><strong>src</strong><ul style='list-style: none; padding-left: 10px; margin: 0;'><li style=\\"margin: 2px 0;\\">hello-world.js</li></ul></li></ul>\\n      </div>\\n      <!-- Right: Editor -->\\n      <div style=\\"flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;\\">\\n        <!-- Editor Tabs -->\\n        <div style=\\"height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;\\">\\n          \\n        </div>\\n        <!-- Editor Content -->\\n        <div style=\\"flex: 1; padding: 5px; overflow: auto; position: relative;\\">\\n          <pre style=\\"margin:0;\\"><code class=\\"language-javascript\\"></code></pre>\\n          \\n        </div>\\n      </div>\\n    </div>\\n    <!-- Bottom: Terminal -->\\n    <div style=\\"height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;\\">\\n      <div style=\\"font-weight: bold;\\">codevideo &gt;</div>\\n      <pre style=\\"margin:0;\\"><code class=\\"language-javascript\\"></code></pre>\\n    </div>\\n    <!-- Mouse Pointer SVG -->\\n    \\n  <svg width=\\"24\\" height=\\"24\\" viewBox=\\"0 0 24 24\\" style=\\"position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;\\">\\n    <path d=\\"M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z\\" fill=\\"black\\" stroke=\\"white\\" stroke-width=\\"1.5\\" stroke-linejoin=\\"round\\"></path>\\n  </svg>\\n  \\n  </div>\\n  ",
    "speak": ""
  },
  {
    "html": \`\\n  <div style=\\\`display: flex; flex-direction: column; height: 100vh; position: relative;\\">\\n    <!-- Main IDE Area -->\\n    <div style=\\"flex: 1; display: flex;\\">\\n      <!-- Left: File Explorer -->\\n      <div style=\\"width: 200px; border: 1px solid black; padding: 5px; overflow: auto;\\">\\n        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style=\\"margin: 2px 0;\\"><strong>src</strong><ul style='list-style: none; padding-left: 10px; margin: 0;'><li style=\\"margin: 2px 0;\\">hello-world.js</li></ul></li></ul>\\n      </div>\\n      <!-- Right: Editor -->\\n      <div style=\\"flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;\\">\\n        <!-- Editor Tabs -->\\n        <div style=\\"height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;\\">\\n          \\n      <div style=\\"\\n          padding: 2px 5px;\\n          border: 1px solid black;\\n          margin-right: 5px;\\n          background: #ddd;\\n          display: inline-block;\\">\\n        src/hello-world.js <span style=\\"color: red;\\">x</span>\\n      </div>\\n        </div>\\n        <!-- Editor Content -->\\n        <div style=\\"flex: 1; padding: 5px; overflow: auto; position: relative;\\">\\n          <pre style=\\"margin:0;\\"><code class=\\"language-javascript\\"></code></pre>\\n          \\n        </div>\\n      </div>\\n    </div>\\n    <!-- Bottom: Terminal -->\\n    <div style=\\"height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;\\">\\n      <div style=\\"font-weight: bold;\\">codevideo &gt;</div>\\n      <pre style=\\"margin:0;\\"><code class=\\"language-javascript\\"></code></pre>\\n    </div>\\n    <!-- Mouse Pointer SVG -->\\n    \\n  <svg width=\\"24\\" height=\\"24\\" viewBox=\\"0 0 24 24\\" style=\\"position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;\\">\\n    <path d=\\"M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z\\" fill=\\"black\\" stroke=\\"white\\" stroke-width=\\"1.5\\" stroke-linejoin=\\"round\\"></path>\\n  </svg>\\n  \\n  </div>\\n  ",
    "speak": ""
  },
  {
    "html": \`\\n  <div style=\\\`display: flex; flex-direction: column; height: 100vh; position: relative;\\">\\n    <!-- Main IDE Area -->\\n    <div style=\\"flex: 1; display: flex;\\">\\n      <!-- Left: File Explorer -->\\n      <div style=\\"width: 200px; border: 1px solid black; padding: 5px; overflow: auto;\\">\\n        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style=\\"margin: 2px 0;\\"><strong>src</strong><ul style='list-style: none; padding-left: 10px; margin: 0;'><li style=\\"margin: 2px 0;\\">hello-world.js</li></ul></li></ul>\\n      </div>\\n      <!-- Right: Editor -->\\n      <div style=\\"flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;\\">\\n        <!-- Editor Tabs -->\\n        <div style=\\"height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;\\">\\n          \\n      <div style=\\"\\n          padding: 2px 5px;\\n          border: 1px solid black;\\n          margin-right: 5px;\\n          background: #ddd;\\n          display: inline-block;\\">\\n        src/hello-world.js <span style=\\"color: red;\\">x</span>\\n      </div>\\n        </div>\\n        <!-- Editor Content -->\\n        <div style=\\"flex: 1; padding: 5px; overflow: auto; position: relative;\\">\\n          <pre style=\\"margin:0;\\"><code class=\\"language-javascript\\"></code></pre>\\n          <div style=\\"\\n      position: absolute;\\n      bottom: 0;\\n      left: 0;\\n      right: 0;\\n      background: rgba(0,0,0,0.7);\\n      color: white;\\n      padding: 5px;\\n      font-size: 14px;\\n      text-align: center;\\n    \\">\\n      To showcase how codevideo works, we're just going to do a super basic hello world example here in src.\\n    </div>\\n        </div>\\n      </div>\\n    </div>\\n    <!-- Bottom: Terminal -->\\n    <div style=\\"height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;\\">\\n      <div style=\\"font-weight: bold;\\">codevideo &gt;</div>\\n      <pre style=\\"margin:0;\\"><code class=\\"language-javascript\\"></code></pre>\\n    </div>\\n    <!-- Mouse Pointer SVG -->\\n    \\n  <svg width=\\"24\\" height=\\"24\\" viewBox=\\"0 0 24 24\\" style=\\"position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;\\">\\n    <path d=\\"M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z\\" fill=\\"black\\" stroke=\\"white\\" stroke-width=\\"1.5\\" stroke-linejoin=\\"round\\"></path>\\n  </svg>\\n  \\n  </div>\\n  ",
    "speak": \`To showcase how codevideo works, we're just going to do a super basic hello world example here in src.\`
  },
  {
    "html": \`\\n  <div style=\\\`display: flex; flex-direction: column; height: 100vh; position: relative;\\">\\n    <!-- Main IDE Area -->\\n    <div style=\\"flex: 1; display: flex;\\">\\n      <!-- Left: File Explorer -->\\n      <div style=\\"width: 200px; border: 1px solid black; padding: 5px; overflow: auto;\\">\\n        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style=\\"margin: 2px 0;\\"><strong>src</strong><ul style='list-style: none; padding-left: 10px; margin: 0;'><li style=\\"margin: 2px 0;\\">hello-world.js</li></ul></li></ul>\\n      </div>\\n      <!-- Right: Editor -->\\n      <div style=\\"flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;\\">\\n        <!-- Editor Tabs -->\\n        <div style=\\"height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;\\">\\n          \\n      <div style=\\"\\n          padding: 2px 5px;\\n          border: 1px solid black;\\n          margin-right: 5px;\\n          background: #ddd;\\n          display: inline-block;\\">\\n        src/hello-world.js <span style=\\"color: red;\\">x</span>\\n      </div>\\n        </div>\\n        <!-- Editor Content -->\\n        <div style=\\"flex: 1; padding: 5px; overflow: auto; position: relative;\\">\\n          <pre style=\\"margin:0;\\"><code class=\\"language-javascript\\">console.log('Hello World!');</code></pre>\\n          <div style=\\"\\n      position: absolute;\\n      bottom: 0;\\n      left: 0;\\n      right: 0;\\n      background: rgba(0,0,0,0.7);\\n      color: white;\\n      padding: 5px;\\n      font-size: 14px;\\n      text-align: center;\\n    \\">\\n      To showcase how codevideo works, we're just going to do a super basic hello world example here in src.\\n    </div>\\n        </div>\\n      </div>\\n    </div>\\n    <!-- Bottom: Terminal -->\\n    <div style=\\"height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;\\">\\n      <div style=\\"font-weight: bold;\\">codevideo &gt;</div>\\n      <pre style=\\"margin:0;\\"><code class=\\"language-javascript\\"></code></pre>\\n    </div>\\n    <!-- Mouse Pointer SVG -->\\n    \\n  <svg width=\\"24\\" height=\\"24\\" viewBox=\\"0 0 24 24\\" style=\\"position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;\\">\\n    <path d=\\"M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z\\" fill=\\"black\\" stroke=\\"white\\" stroke-width=\\"1.5\\" stroke-linejoin=\\"round\\"></path>\\n  </svg>\\n  \\n  </div>\\n  ",
    "speak": ""
  },
  {
    "html": \`\\n  <div style=\\\`display: flex; flex-direction: column; height: 100vh; position: relative;\\">\\n    <!-- Main IDE Area -->\\n    <div style=\\"flex: 1; display: flex;\\">\\n      <!-- Left: File Explorer -->\\n      <div style=\\"width: 200px; border: 1px solid black; padding: 5px; overflow: auto;\\">\\n        <ul style='list-style: none; padding-left: 10px; margin: 0;'><li style=\\"margin: 2px 0;\\"><strong>src</strong><ul style='list-style: none; padding-left: 10px; margin: 0;'><li style=\\"margin: 2px 0;\\">hello-world.js</li></ul></li></ul>\\n      </div>\\n      <!-- Right: Editor -->\\n      <div style=\\"flex: 1; border: 1px solid black; display: flex; flex-direction: column; position: relative;\\">\\n        <!-- Editor Tabs -->\\n        <div style=\\"height: 30px; border-bottom: 1px solid black; padding: 5px; overflow-x: auto;\\">\\n          \\n      <div style=\\"\\n          padding: 2px 5px;\\n          border: 1px solid black;\\n          margin-right: 5px;\\n          background: #ddd;\\n          display: inline-block;\\">\\n        src/hello-world.js <span style=\\"color: red;\\">x</span>\\n      </div>\\n        </div>\\n        <!-- Editor Content -->\\n        <div style=\\"flex: 1; padding: 5px; overflow: auto; position: relative;\\">\\n          <pre style=\\"margin:0;\\"><code class=\\"language-javascript\\">console.log('Hello World!');</code></pre>\\n          <div style=\\"\\n      position: absolute;\\n      bottom: 0;\\n      left: 0;\\n      right: 0;\\n      background: rgba(0,0,0,0.7);\\n      color: white;\\n      padding: 5px;\\n      font-size: 14px;\\n      text-align: center;\\n    \\">\\n      Nice, that looks pretty good! Pretty cool tool, right?!\\n    </div>\\n        </div>\\n      </div>\\n    </div>\\n    <!-- Bottom: Terminal -->\\n    <div style=\\"height: 150px; border: 1px solid black; padding: 5px; overflow: auto; font-family: monospace;\\">\\n      <div style=\\"font-weight: bold;\\">codevideo &gt;</div>\\n      <pre style=\\"margin:0;\\"><code class=\\"language-javascript\\"></code></pre>\\n    </div>\\n    <!-- Mouse Pointer SVG -->\\n    \\n  <svg width=\\"24\\" height=\\"24\\" viewBox=\\"0 0 24 24\\" style=\\"position: absolute; left: -2px; top: -2px; pointer-events: none; transform: scale(0.8); z-index: 1000;\\">\\n    <path d=\\"M 0,0 L 0,20 L 4.5,15.5 L 8.75,23 L 11,22 L 6.75,15 L 13.75,15 Z\\" fill=\\"black\\" stroke=\\"white\\" stroke-width=\\"1.5\\" stroke-linejoin=\\"round\\"></path>\\n  </svg>\\n  \\n  </div>\\n  ",
    "speak": \`Nice, that looks pretty good! Pretty cool tool, right?!\`
  }
];
"
`;

exports[`VirtualIDE Snapshot with IDE Layout should generate separated snapshots.js and viewer.html files: Generated viewer HTML 1`] = `
"<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>VirtualIDE Snapshot Viewer</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
    <style>
      body {
        font-size: 18px;
        margin: 0;
        padding: 0;
        font-family: monospace;
        background: #fafafa;
      }
      #snapshot-container {
        height: calc(100vh - 40px);
        overflow: auto;
        position: relative;
      }
      #nav-indicator {
        text-align: center;
        padding: 8px;
        background: #eee;
        border-top: 1px solid black;
      }
    </style>
  </head>
  <body>
    <div id="snapshot-container"></div>
    <div id="nav-indicator"></div>
    <script type="module">
      import { snapshots } from './snapshots.js';
      
      let currentIndex = 0;
      
      function showSnapshot(index) {
        if (index < 0 || index >= snapshots.length) return;
        currentIndex = index;
        
        const container = document.getElementById("snapshot-container");
        container.innerHTML = snapshots[index].html;
        
        document.getElementById("nav-indicator").innerText =
          \`Step \${index + 1} of \${snapshots.length}\`;
        
        if (window.Prism) {
          Prism.highlightAll();
        }

        const speakText = snapshots[index].speak;
        if (speakText) {
          const utterance = new SpeechSynthesisUtterance(speakText);
          window.speechSynthesis.cancel();
          window.speechSynthesis.speak(utterance);
        }
      }

      document.addEventListener("keydown", (event) => {
        if (event.key === "ArrowRight" && currentIndex < snapshots.length - 1) {
          showSnapshot(currentIndex + 1);
        } else if (event.key === "ArrowLeft" && currentIndex > 0) {
          showSnapshot(currentIndex - 1);
        }
      });

      // Show the first snapshot on load
      showSnapshot(0);
    </script>
  </body>
</html>"
`;
